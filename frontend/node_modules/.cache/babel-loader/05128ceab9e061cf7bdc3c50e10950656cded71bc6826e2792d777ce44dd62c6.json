{"ast":null,"code":"/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseConnection = require('../../connection');\nconst MongooseError = require('../../error/index');\nconst STATES = require('../../connectionState');\nconst mongodb = require('mongodb');\nconst pkg = require('../../../package.json');\nconst processConnectionOptions = require('../../helpers/processConnectionOptions');\nconst setTimeout = require('../../helpers/timers').setTimeout;\nconst utils = require('../../utils');\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.\n *\n * @inherits Connection\n * @api private\n */\n\nfunction NativeConnection() {\n  MongooseConnection.apply(this, arguments);\n  this._listening = false;\n}\n\n/**\n * Expose the possible connection states.\n * @api public\n */\n\nNativeConnection.STATES = STATES;\n\n/*!\n * Inherits from Connection.\n */\n\nObject.setPrototypeOf(NativeConnection.prototype, MongooseConnection.prototype);\n\n/**\n * Switches to a different database using the same connection pool.\n *\n * Returns a new connection object, with the new db. If you set the `useCache`\n * option, `useDb()` will cache connections by `name`.\n *\n * **Note:** Calling `close()` on a `useDb()` connection will close the base connection as well.\n *\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @param {Boolean} [options.noListener=false] If true, the new connection object won't listen to any events on the base connection. This is better for memory usage in cases where you're calling `useDb()` for every request.\n * @return {Connection} New Connection Object\n * @api public\n */\n\nNativeConnection.prototype.useDb = function (name, options) {\n  // Return immediately if cached\n  options = options || {};\n  if (options.useCache && this.relatedDbs[name]) {\n    return this.relatedDbs[name];\n  }\n\n  // we have to manually copy all of the attributes...\n  const newConn = new this.constructor();\n  newConn.name = name;\n  newConn.base = this.base;\n  newConn.collections = {};\n  newConn.models = {};\n  newConn.replica = this.replica;\n  newConn.config = Object.assign({}, this.config, newConn.config);\n  newConn.name = this.name;\n  newConn.options = this.options;\n  newConn._readyState = this._readyState;\n  newConn._closeCalled = this._closeCalled;\n  newConn._hasOpened = this._hasOpened;\n  newConn._listening = false;\n  newConn._parent = this;\n  newConn.host = this.host;\n  newConn.port = this.port;\n  newConn.user = this.user;\n  newConn.pass = this.pass;\n\n  // First, when we create another db object, we are not guaranteed to have a\n  // db object to work with. So, in the case where we have a db object and it\n  // is connected, we can just proceed with setting everything up. However, if\n  // we do not have a db or the state is not connected, then we need to wait on\n  // the 'open' event of the connection before doing the rest of the setup\n  // the 'connected' event is the first time we'll have access to the db object\n\n  const _this = this;\n  newConn.client = _this.client;\n  if (this.db && this._readyState === STATES.connected) {\n    wireup();\n  } else {\n    this.once('connected', wireup);\n  }\n  function wireup() {\n    newConn.client = _this.client;\n    const _opts = {};\n    if (options.hasOwnProperty('noListener')) {\n      _opts.noListener = options.noListener;\n    }\n    newConn.db = _this.client.db(name, _opts);\n    newConn.onOpen();\n  }\n  newConn.name = name;\n\n  // push onto the otherDbs stack, this is used when state changes\n  if (options.noListener !== true) {\n    this.otherDbs.push(newConn);\n  }\n  newConn.otherDbs.push(this);\n\n  // push onto the relatedDbs cache, this is used when state changes\n  if (options && options.useCache) {\n    this.relatedDbs[newConn.name] = newConn;\n    newConn.relatedDbs = this.relatedDbs;\n  }\n  return newConn;\n};\n\n/**\n * Removes the database connection with the given name created with `useDb()`.\n *\n * Throws an error if the database connection was not found.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *\n *     // Closes `db`, and removes `db` from `conn.relatedDbs` and `conn.otherDbs`\n *     await conn.removeDb('mydb');\n *\n * @method removeDb\n * @memberOf Connection\n * @param {String} name The database name\n * @return {Connection} this\n */\n\nNativeConnection.prototype.removeDb = function removeDb(name) {\n  const dbs = this.otherDbs.filter(db => db.name === name);\n  if (!dbs.length) {\n    throw new MongooseError(`No connections to database \"${name}\" found`);\n  }\n  for (const db of dbs) {\n    db._closeCalled = true;\n    db._destroyCalled = true;\n    db._readyState = STATES.disconnected;\n    db.$wasForceClosed = true;\n  }\n  delete this.relatedDbs[name];\n  this.otherDbs = this.otherDbs.filter(db => db.name !== name);\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force]\n * @return {Connection} this\n * @api private\n */\n\nNativeConnection.prototype.doClose = async function doClose(force) {\n  if (this.client == null) {\n    return this;\n  }\n  let skipCloseClient = false;\n  if (force != null && typeof force === 'object') {\n    skipCloseClient = force.skipCloseClient;\n    force = force.force;\n  }\n  if (skipCloseClient) {\n    return this;\n  }\n  await this.client.close(force);\n  // Defer because the driver will wait at least 1ms before finishing closing\n  // the pool, see https://github.com/mongodb-js/mongodb-core/blob/a8f8e4ce41936babc3b9112bf42d609779f03b39/lib/connection/pool.js#L1026-L1030.\n  // If there's queued operations, you may still get some background work\n  // after the callback is called.\n  await new Promise(resolve => setTimeout(resolve, 1));\n  return this;\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.createClient = async function createClient(uri, options) {\n  if (typeof uri !== 'string') {\n    throw new MongooseError('The `uri` parameter to `openUri()` must be a ' + `string, got \"${typeof uri}\". Make sure the first parameter to ` + '`mongoose.connect()` or `mongoose.createConnection()` is a string.');\n  }\n  if (this._destroyCalled) {\n    throw new MongooseError('Connection has been closed and destroyed, and cannot be used for re-opening the connection. ' + 'Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.');\n  }\n  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {\n    if (this._connectionString !== uri) {\n      throw new MongooseError('Can\\'t call `openUri()` on an active connection with ' + 'different connection strings. Make sure you aren\\'t calling `mongoose.connect()` ' + 'multiple times. See: https://mongoosejs.com/docs/connections.html#multiple_connections');\n    }\n  }\n  options = processConnectionOptions(uri, options);\n  if (options) {\n    const autoIndex = options.config && options.config.autoIndex != null ? options.config.autoIndex : options.autoIndex;\n    if (autoIndex != null) {\n      this.config.autoIndex = autoIndex !== false;\n      delete options.config;\n      delete options.autoIndex;\n    }\n    if ('autoCreate' in options) {\n      this.config.autoCreate = !!options.autoCreate;\n      delete options.autoCreate;\n    }\n    if ('sanitizeFilter' in options) {\n      this.config.sanitizeFilter = options.sanitizeFilter;\n      delete options.sanitizeFilter;\n    }\n    if ('autoSearchIndex' in options) {\n      this.config.autoSearchIndex = options.autoSearchIndex;\n      delete options.autoSearchIndex;\n    }\n\n    // Backwards compat\n    if (options.user || options.pass) {\n      options.auth = options.auth || {};\n      options.auth.username = options.user;\n      options.auth.password = options.pass;\n      this.user = options.user;\n      this.pass = options.pass;\n    }\n    delete options.user;\n    delete options.pass;\n    if (options.bufferCommands != null) {\n      this.config.bufferCommands = options.bufferCommands;\n      delete options.bufferCommands;\n    }\n  } else {\n    options = {};\n  }\n  this._connectionOptions = options;\n  const dbName = options.dbName;\n  if (dbName != null) {\n    this.$dbName = dbName;\n  }\n  delete options.dbName;\n  if (!utils.hasUserDefinedProperty(options, 'driverInfo')) {\n    options.driverInfo = {\n      name: 'Mongoose',\n      version: pkg.version\n    };\n  }\n  this.readyState = STATES.connecting;\n  this._connectionString = uri;\n  let client;\n  try {\n    client = new mongodb.MongoClient(uri, options);\n  } catch (error) {\n    this.readyState = STATES.disconnected;\n    throw error;\n  }\n  this.client = client;\n  client.setMaxListeners(0);\n  await client.connect();\n  _setClient(this, client, options, dbName);\n  for (const db of this.otherDbs) {\n    _setClient(db, client, {}, db.name);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.setClient = function setClient(client) {\n  if (!(client instanceof mongodb.MongoClient)) {\n    throw new MongooseError('Must call `setClient()` with an instance of MongoClient');\n  }\n  if (this.readyState !== STATES.disconnected) {\n    throw new MongooseError('Cannot call `setClient()` on a connection that is already connected.');\n  }\n  if (client.topology == null) {\n    throw new MongooseError('Cannot call `setClient()` with a MongoClient that you have not called `connect()` on yet.');\n  }\n  this._connectionString = client.s.url;\n  _setClient(this, client, {}, client.s.options.dbName);\n  for (const model of Object.values(this.models)) {\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _setClient(conn, client, options, dbName) {\n  const db = dbName != null ? client.db(dbName) : client.db();\n  conn.db = db;\n  conn.client = client;\n  conn.host = client && client.s && client.s.options && client.s.options.hosts && client.s.options.hosts[0] && client.s.options.hosts[0].host || void 0;\n  conn.port = client && client.s && client.s.options && client.s.options.hosts && client.s.options.hosts[0] && client.s.options.hosts[0].port || void 0;\n  conn.name = dbName != null ? dbName : db.databaseName;\n  conn._closeCalled = client._closeCalled;\n  const _handleReconnect = () => {\n    // If we aren't disconnected, we assume this reconnect is due to a\n    // socket timeout. If there's no activity on a socket for\n    // `socketTimeoutMS`, the driver will attempt to reconnect and emit\n    // this event.\n    if (conn.readyState !== STATES.connected) {\n      conn.readyState = STATES.connected;\n      conn.emit('reconnect');\n      conn.emit('reconnected');\n      conn.onOpen();\n    }\n  };\n  const type = client && client.topology && client.topology.description && client.topology.description.type || '';\n  if (type === 'Single') {\n    client.on('serverDescriptionChanged', ev => {\n      const newDescription = ev.newDescription;\n      if (newDescription.type === 'Unknown') {\n        conn.readyState = STATES.disconnected;\n      } else {\n        _handleReconnect();\n      }\n    });\n  } else if (type.startsWith('ReplicaSet')) {\n    client.on('topologyDescriptionChanged', ev => {\n      // Emit disconnected if we've lost connectivity to the primary\n      const description = ev.newDescription;\n      if (conn.readyState === STATES.connected && description.type !== 'ReplicaSetWithPrimary') {\n        // Implicitly emits 'disconnected'\n        conn.readyState = STATES.disconnected;\n      } else if (conn.readyState === STATES.disconnected && description.type === 'ReplicaSetWithPrimary') {\n        _handleReconnect();\n      }\n    });\n  }\n  conn.onOpen();\n  for (const i in conn.collections) {\n    if (utils.object.hasOwnProperty(conn.collections, i)) {\n      conn.collections[i].onOpen();\n    }\n  }\n}\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeConnection;","map":{"version":3,"names":["MongooseConnection","require","MongooseError","STATES","mongodb","pkg","processConnectionOptions","setTimeout","utils","NativeConnection","apply","arguments","_listening","Object","setPrototypeOf","prototype","useDb","name","options","useCache","relatedDbs","newConn","constructor","base","collections","models","replica","config","assign","_readyState","_closeCalled","_hasOpened","_parent","host","port","user","pass","_this","client","db","connected","wireup","once","_opts","hasOwnProperty","noListener","onOpen","otherDbs","push","removeDb","dbs","filter","length","_destroyCalled","disconnected","$wasForceClosed","doClose","force","skipCloseClient","close","Promise","resolve","createClient","uri","readyState","connecting","_connectionString","autoIndex","autoCreate","sanitizeFilter","autoSearchIndex","auth","username","password","bufferCommands","_connectionOptions","dbName","$dbName","hasUserDefinedProperty","driverInfo","version","MongoClient","error","setMaxListeners","connect","_setClient","setClient","topology","s","url","model","values","init","catch","$modelInitNoop","conn","hosts","databaseName","_handleReconnect","emit","type","description","on","ev","newDescription","startsWith","i","object","module","exports"],"sources":["C:/Users/lrmir/OneDrive/Desktop/cs35L/newFridayz/Fridayz/frontend/node_modules/mongoose/lib/drivers/node-mongodb-native/connection.js"],"sourcesContent":["/*!\n * Module dependencies.\n */\n\n'use strict';\n\nconst MongooseConnection = require('../../connection');\nconst MongooseError = require('../../error/index');\nconst STATES = require('../../connectionState');\nconst mongodb = require('mongodb');\nconst pkg = require('../../../package.json');\nconst processConnectionOptions = require('../../helpers/processConnectionOptions');\nconst setTimeout = require('../../helpers/timers').setTimeout;\nconst utils = require('../../utils');\n\n/**\n * A [node-mongodb-native](https://github.com/mongodb/node-mongodb-native) connection implementation.\n *\n * @inherits Connection\n * @api private\n */\n\nfunction NativeConnection() {\n  MongooseConnection.apply(this, arguments);\n  this._listening = false;\n}\n\n/**\n * Expose the possible connection states.\n * @api public\n */\n\nNativeConnection.STATES = STATES;\n\n/*!\n * Inherits from Connection.\n */\n\nObject.setPrototypeOf(NativeConnection.prototype, MongooseConnection.prototype);\n\n/**\n * Switches to a different database using the same connection pool.\n *\n * Returns a new connection object, with the new db. If you set the `useCache`\n * option, `useDb()` will cache connections by `name`.\n *\n * **Note:** Calling `close()` on a `useDb()` connection will close the base connection as well.\n *\n * @param {String} name The database name\n * @param {Object} [options]\n * @param {Boolean} [options.useCache=false] If true, cache results so calling `useDb()` multiple times with the same name only creates 1 connection object.\n * @param {Boolean} [options.noListener=false] If true, the new connection object won't listen to any events on the base connection. This is better for memory usage in cases where you're calling `useDb()` for every request.\n * @return {Connection} New Connection Object\n * @api public\n */\n\nNativeConnection.prototype.useDb = function(name, options) {\n  // Return immediately if cached\n  options = options || {};\n  if (options.useCache && this.relatedDbs[name]) {\n    return this.relatedDbs[name];\n  }\n\n  // we have to manually copy all of the attributes...\n  const newConn = new this.constructor();\n  newConn.name = name;\n  newConn.base = this.base;\n  newConn.collections = {};\n  newConn.models = {};\n  newConn.replica = this.replica;\n  newConn.config = Object.assign({}, this.config, newConn.config);\n  newConn.name = this.name;\n  newConn.options = this.options;\n  newConn._readyState = this._readyState;\n  newConn._closeCalled = this._closeCalled;\n  newConn._hasOpened = this._hasOpened;\n  newConn._listening = false;\n  newConn._parent = this;\n\n  newConn.host = this.host;\n  newConn.port = this.port;\n  newConn.user = this.user;\n  newConn.pass = this.pass;\n\n  // First, when we create another db object, we are not guaranteed to have a\n  // db object to work with. So, in the case where we have a db object and it\n  // is connected, we can just proceed with setting everything up. However, if\n  // we do not have a db or the state is not connected, then we need to wait on\n  // the 'open' event of the connection before doing the rest of the setup\n  // the 'connected' event is the first time we'll have access to the db object\n\n  const _this = this;\n\n  newConn.client = _this.client;\n\n  if (this.db && this._readyState === STATES.connected) {\n    wireup();\n  } else {\n    this.once('connected', wireup);\n  }\n\n  function wireup() {\n    newConn.client = _this.client;\n    const _opts = {};\n    if (options.hasOwnProperty('noListener')) {\n      _opts.noListener = options.noListener;\n    }\n    newConn.db = _this.client.db(name, _opts);\n    newConn.onOpen();\n  }\n\n  newConn.name = name;\n\n  // push onto the otherDbs stack, this is used when state changes\n  if (options.noListener !== true) {\n    this.otherDbs.push(newConn);\n  }\n  newConn.otherDbs.push(this);\n\n  // push onto the relatedDbs cache, this is used when state changes\n  if (options && options.useCache) {\n    this.relatedDbs[newConn.name] = newConn;\n    newConn.relatedDbs = this.relatedDbs;\n  }\n\n  return newConn;\n};\n\n/**\n * Removes the database connection with the given name created with `useDb()`.\n *\n * Throws an error if the database connection was not found.\n *\n * #### Example:\n *\n *     // Connect to `initialdb` first\n *     const conn = await mongoose.createConnection('mongodb://127.0.0.1:27017/initialdb').asPromise();\n *\n *     // Creates an un-cached connection to `mydb`\n *     const db = conn.useDb('mydb');\n *\n *     // Closes `db`, and removes `db` from `conn.relatedDbs` and `conn.otherDbs`\n *     await conn.removeDb('mydb');\n *\n * @method removeDb\n * @memberOf Connection\n * @param {String} name The database name\n * @return {Connection} this\n */\n\nNativeConnection.prototype.removeDb = function removeDb(name) {\n  const dbs = this.otherDbs.filter(db => db.name === name);\n  if (!dbs.length) {\n    throw new MongooseError(`No connections to database \"${name}\" found`);\n  }\n\n  for (const db of dbs) {\n    db._closeCalled = true;\n    db._destroyCalled = true;\n    db._readyState = STATES.disconnected;\n    db.$wasForceClosed = true;\n  }\n  delete this.relatedDbs[name];\n  this.otherDbs = this.otherDbs.filter(db => db.name !== name);\n};\n\n/**\n * Closes the connection\n *\n * @param {Boolean} [force]\n * @return {Connection} this\n * @api private\n */\n\nNativeConnection.prototype.doClose = async function doClose(force) {\n  if (this.client == null) {\n    return this;\n  }\n\n  let skipCloseClient = false;\n  if (force != null && typeof force === 'object') {\n    skipCloseClient = force.skipCloseClient;\n    force = force.force;\n  }\n\n  if (skipCloseClient) {\n    return this;\n  }\n\n  await this.client.close(force);\n  // Defer because the driver will wait at least 1ms before finishing closing\n  // the pool, see https://github.com/mongodb-js/mongodb-core/blob/a8f8e4ce41936babc3b9112bf42d609779f03b39/lib/connection/pool.js#L1026-L1030.\n  // If there's queued operations, you may still get some background work\n  // after the callback is called.\n  await new Promise(resolve => setTimeout(resolve, 1));\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.createClient = async function createClient(uri, options) {\n  if (typeof uri !== 'string') {\n    throw new MongooseError('The `uri` parameter to `openUri()` must be a ' +\n      `string, got \"${typeof uri}\". Make sure the first parameter to ` +\n      '`mongoose.connect()` or `mongoose.createConnection()` is a string.');\n  }\n\n  if (this._destroyCalled) {\n    throw new MongooseError(\n      'Connection has been closed and destroyed, and cannot be used for re-opening the connection. ' +\n      'Please create a new connection with `mongoose.createConnection()` or `mongoose.connect()`.'\n    );\n  }\n\n  if (this.readyState === STATES.connecting || this.readyState === STATES.connected) {\n    if (this._connectionString !== uri) {\n      throw new MongooseError('Can\\'t call `openUri()` on an active connection with ' +\n        'different connection strings. Make sure you aren\\'t calling `mongoose.connect()` ' +\n        'multiple times. See: https://mongoosejs.com/docs/connections.html#multiple_connections');\n    }\n  }\n\n  options = processConnectionOptions(uri, options);\n\n  if (options) {\n\n    const autoIndex = options.config && options.config.autoIndex != null ?\n      options.config.autoIndex :\n      options.autoIndex;\n    if (autoIndex != null) {\n      this.config.autoIndex = autoIndex !== false;\n      delete options.config;\n      delete options.autoIndex;\n    }\n\n    if ('autoCreate' in options) {\n      this.config.autoCreate = !!options.autoCreate;\n      delete options.autoCreate;\n    }\n\n    if ('sanitizeFilter' in options) {\n      this.config.sanitizeFilter = options.sanitizeFilter;\n      delete options.sanitizeFilter;\n    }\n\n    if ('autoSearchIndex' in options) {\n      this.config.autoSearchIndex = options.autoSearchIndex;\n      delete options.autoSearchIndex;\n    }\n\n    // Backwards compat\n    if (options.user || options.pass) {\n      options.auth = options.auth || {};\n      options.auth.username = options.user;\n      options.auth.password = options.pass;\n\n      this.user = options.user;\n      this.pass = options.pass;\n    }\n    delete options.user;\n    delete options.pass;\n\n    if (options.bufferCommands != null) {\n      this.config.bufferCommands = options.bufferCommands;\n      delete options.bufferCommands;\n    }\n  } else {\n    options = {};\n  }\n\n  this._connectionOptions = options;\n  const dbName = options.dbName;\n  if (dbName != null) {\n    this.$dbName = dbName;\n  }\n  delete options.dbName;\n\n  if (!utils.hasUserDefinedProperty(options, 'driverInfo')) {\n    options.driverInfo = {\n      name: 'Mongoose',\n      version: pkg.version\n    };\n  }\n\n  this.readyState = STATES.connecting;\n  this._connectionString = uri;\n\n  let client;\n  try {\n    client = new mongodb.MongoClient(uri, options);\n  } catch (error) {\n    this.readyState = STATES.disconnected;\n    throw error;\n  }\n  this.client = client;\n\n  client.setMaxListeners(0);\n  await client.connect();\n\n  _setClient(this, client, options, dbName);\n\n  for (const db of this.otherDbs) {\n    _setClient(db, client, {}, db.name);\n  }\n  return this;\n};\n\n/*!\n * ignore\n */\n\nNativeConnection.prototype.setClient = function setClient(client) {\n  if (!(client instanceof mongodb.MongoClient)) {\n    throw new MongooseError('Must call `setClient()` with an instance of MongoClient');\n  }\n  if (this.readyState !== STATES.disconnected) {\n    throw new MongooseError('Cannot call `setClient()` on a connection that is already connected.');\n  }\n  if (client.topology == null) {\n    throw new MongooseError('Cannot call `setClient()` with a MongoClient that you have not called `connect()` on yet.');\n  }\n\n  this._connectionString = client.s.url;\n  _setClient(this, client, {}, client.s.options.dbName);\n\n  for (const model of Object.values(this.models)) {\n    // Errors handled internally, so safe to ignore error\n    model.init().catch(function $modelInitNoop() {});\n  }\n\n  return this;\n};\n\n/*!\n * ignore\n */\n\nfunction _setClient(conn, client, options, dbName) {\n  const db = dbName != null ? client.db(dbName) : client.db();\n  conn.db = db;\n  conn.client = client;\n  conn.host = client &&\n    client.s &&\n    client.s.options &&\n    client.s.options.hosts &&\n    client.s.options.hosts[0] &&\n    client.s.options.hosts[0].host || void 0;\n  conn.port = client &&\n    client.s &&\n    client.s.options &&\n    client.s.options.hosts &&\n    client.s.options.hosts[0] &&\n    client.s.options.hosts[0].port || void 0;\n  conn.name = dbName != null ? dbName : db.databaseName;\n  conn._closeCalled = client._closeCalled;\n\n  const _handleReconnect = () => {\n    // If we aren't disconnected, we assume this reconnect is due to a\n    // socket timeout. If there's no activity on a socket for\n    // `socketTimeoutMS`, the driver will attempt to reconnect and emit\n    // this event.\n    if (conn.readyState !== STATES.connected) {\n      conn.readyState = STATES.connected;\n      conn.emit('reconnect');\n      conn.emit('reconnected');\n      conn.onOpen();\n    }\n  };\n\n  const type = client &&\n  client.topology &&\n  client.topology.description &&\n  client.topology.description.type || '';\n\n  if (type === 'Single') {\n    client.on('serverDescriptionChanged', ev => {\n      const newDescription = ev.newDescription;\n      if (newDescription.type === 'Unknown') {\n        conn.readyState = STATES.disconnected;\n      } else {\n        _handleReconnect();\n      }\n    });\n  } else if (type.startsWith('ReplicaSet')) {\n    client.on('topologyDescriptionChanged', ev => {\n      // Emit disconnected if we've lost connectivity to the primary\n      const description = ev.newDescription;\n      if (conn.readyState === STATES.connected && description.type !== 'ReplicaSetWithPrimary') {\n        // Implicitly emits 'disconnected'\n        conn.readyState = STATES.disconnected;\n      } else if (conn.readyState === STATES.disconnected && description.type === 'ReplicaSetWithPrimary') {\n        _handleReconnect();\n      }\n    });\n  }\n\n  conn.onOpen();\n\n  for (const i in conn.collections) {\n    if (utils.object.hasOwnProperty(conn.collections, i)) {\n      conn.collections[i].onOpen();\n    }\n  }\n}\n\n\n/*!\n * Module exports.\n */\n\nmodule.exports = NativeConnection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}