{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst Binary = require('bson').Binary;\nconst isBsonType = require('./isBsonType');\nconst isMongooseObject = require('./isMongooseObject');\nconst MongooseError = require('../error');\nconst util = require('util');\nexports.flatten = flatten;\nexports.modifiedPaths = modifiedPaths;\n\n/*!\n * ignore\n */\n\nfunction flatten(update, path, options, schema) {\n  let keys;\n  if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {\n    keys = Object.keys(update.toObject({\n      transform: false,\n      virtuals: false\n    }) || {});\n  } else {\n    keys = Object.keys(update || {});\n  }\n  const numKeys = keys.length;\n  const result = {};\n  path = path ? path + '.' : '';\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const val = update[key];\n    result[path + key] = val;\n\n    // Avoid going into mixed paths if schema is specified\n    const keySchema = schema && schema.path && schema.path(path + key);\n    const isNested = schema && schema.nested && schema.nested[path + key];\n    if (keySchema && keySchema.instance === 'Mixed') continue;\n    if (shouldFlatten(val)) {\n      if (options && options.skipArrays && Array.isArray(val)) {\n        continue;\n      }\n      const flat = flatten(val, path + key, options, schema);\n      for (const k in flat) {\n        result[k] = flat[k];\n      }\n      if (Array.isArray(val)) {\n        result[path + key] = val;\n      }\n    }\n    if (isNested) {\n      const paths = Object.keys(schema.paths);\n      for (const p of paths) {\n        if (p.startsWith(path + key + '.') && !result.hasOwnProperty(p)) {\n          result[p] = void 0;\n        }\n      }\n    }\n  }\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction modifiedPaths(update, path, result, recursion = null) {\n  if (update == null || typeof update !== 'object') {\n    return;\n  }\n  if (recursion == null) {\n    recursion = {\n      raw: {\n        update,\n        path\n      },\n      trace: new WeakSet()\n    };\n  }\n  if (recursion.trace.has(update)) {\n    throw new MongooseError(`a circular reference in the update value, updateValue:\n${util.inspect(recursion.raw.update, {\n      showHidden: false,\n      depth: 1\n    })}\nupdatePath: '${recursion.raw.path}'`);\n  }\n  recursion.trace.add(update);\n  const keys = Object.keys(update || {});\n  const numKeys = keys.length;\n  result = result || {};\n  path = path ? path + '.' : '';\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    let val = update[key];\n    const _path = path + key;\n    result[_path] = true;\n    if (!Buffer.isBuffer(val) && isMongooseObject(val)) {\n      val = val.toObject({\n        transform: false,\n        virtuals: false\n      });\n    }\n    if (shouldFlatten(val)) {\n      modifiedPaths(val, path + key, result, recursion);\n    }\n  }\n  recursion.trace.delete(update);\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction shouldFlatten(val) {\n  return val && typeof val === 'object' && !(val instanceof Date) && !isBsonType(val, 'ObjectId') && (!Array.isArray(val) || val.length !== 0) && !(val instanceof Buffer) && !isBsonType(val, 'Decimal128') && !(val instanceof Binary);\n}","map":{"version":3,"names":["Binary","require","isBsonType","isMongooseObject","MongooseError","util","exports","flatten","modifiedPaths","update","path","options","schema","keys","Buffer","isBuffer","Object","toObject","transform","virtuals","numKeys","length","result","i","key","val","keySchema","isNested","nested","instance","shouldFlatten","skipArrays","Array","isArray","flat","k","paths","p","startsWith","hasOwnProperty","recursion","raw","trace","WeakSet","has","inspect","showHidden","depth","add","_path","delete","Date"],"sources":["C:/Users/lrmir/OneDrive/Desktop/cs35L/newFridayz/Fridayz/frontend/node_modules/mongoose/lib/helpers/common.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst Binary = require('bson').Binary;\nconst isBsonType = require('./isBsonType');\nconst isMongooseObject = require('./isMongooseObject');\nconst MongooseError = require('../error');\nconst util = require('util');\n\nexports.flatten = flatten;\nexports.modifiedPaths = modifiedPaths;\n\n/*!\n * ignore\n */\n\nfunction flatten(update, path, options, schema) {\n  let keys;\n  if (update && isMongooseObject(update) && !Buffer.isBuffer(update)) {\n    keys = Object.keys(update.toObject({ transform: false, virtuals: false }) || {});\n  } else {\n    keys = Object.keys(update || {});\n  }\n\n  const numKeys = keys.length;\n  const result = {};\n  path = path ? path + '.' : '';\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    const val = update[key];\n    result[path + key] = val;\n\n    // Avoid going into mixed paths if schema is specified\n    const keySchema = schema && schema.path && schema.path(path + key);\n    const isNested = schema && schema.nested && schema.nested[path + key];\n    if (keySchema && keySchema.instance === 'Mixed') continue;\n\n    if (shouldFlatten(val)) {\n      if (options && options.skipArrays && Array.isArray(val)) {\n        continue;\n      }\n      const flat = flatten(val, path + key, options, schema);\n      for (const k in flat) {\n        result[k] = flat[k];\n      }\n      if (Array.isArray(val)) {\n        result[path + key] = val;\n      }\n    }\n\n    if (isNested) {\n      const paths = Object.keys(schema.paths);\n      for (const p of paths) {\n        if (p.startsWith(path + key + '.') && !result.hasOwnProperty(p)) {\n          result[p] = void 0;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction modifiedPaths(update, path, result, recursion = null) {\n  if (update == null || typeof update !== 'object') {\n    return;\n  }\n\n  if (recursion == null) {\n    recursion = {\n      raw: { update, path },\n      trace: new WeakSet()\n    };\n  }\n\n  if (recursion.trace.has(update)) {\n    throw new MongooseError(`a circular reference in the update value, updateValue:\n${util.inspect(recursion.raw.update, { showHidden: false, depth: 1 })}\nupdatePath: '${recursion.raw.path}'`);\n  }\n  recursion.trace.add(update);\n\n  const keys = Object.keys(update || {});\n  const numKeys = keys.length;\n  result = result || {};\n  path = path ? path + '.' : '';\n\n  for (let i = 0; i < numKeys; ++i) {\n    const key = keys[i];\n    let val = update[key];\n\n    const _path = path + key;\n    result[_path] = true;\n    if (!Buffer.isBuffer(val) && isMongooseObject(val)) {\n      val = val.toObject({ transform: false, virtuals: false });\n    }\n    if (shouldFlatten(val)) {\n      modifiedPaths(val, path + key, result, recursion);\n    }\n  }\n  recursion.trace.delete(update);\n\n  return result;\n}\n\n/*!\n * ignore\n */\n\nfunction shouldFlatten(val) {\n  return val &&\n      typeof val === 'object' &&\n      !(val instanceof Date) &&\n      !isBsonType(val, 'ObjectId') &&\n      (!Array.isArray(val) || val.length !== 0) &&\n      !(val instanceof Buffer) &&\n      !isBsonType(val, 'Decimal128') &&\n      !(val instanceof Binary);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}