{"ast":null,"code":"'use strict';\n\nconst schemaMerge = require('../schema/merge');\nconst specialProperties = require('../../helpers/specialProperties');\nconst isBsonType = require('../../helpers/isBsonType');\nconst ObjectId = require('../../types/objectid');\nconst isObject = require('../../helpers/isObject');\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @param {String} [path]\n * @api private\n */\n\nmodule.exports = function mergeDiscriminatorSchema(to, from, path, seen) {\n  const keys = Object.keys(from);\n  let i = 0;\n  const len = keys.length;\n  let key;\n  path = path || '';\n  seen = seen || new WeakSet();\n  if (seen.has(from)) {\n    return;\n  }\n  seen.add(from);\n  while (i < len) {\n    key = keys[i++];\n    if (!path) {\n      if (key === 'discriminators' || key === 'base' || key === '_applyDiscriminators' || key === '_userProvidedOptions' || key === 'options' || key === 'tree') {\n        continue;\n      }\n    }\n    if (path === 'tree' && from != null && from.instanceOfSchema) {\n      continue;\n    }\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    if (to[key] == null) {\n      to[key] = from[key];\n    } else if (isObject(from[key])) {\n      if (!isObject(to[key])) {\n        to[key] = {};\n      }\n      if (from[key] != null) {\n        // Skip merging schemas if we're creating a discriminator schema and\n        // base schema has a given path as a single nested but discriminator schema\n        // has the path as a document array, or vice versa (gh-9534)\n        if (from[key].$isSingleNested && to[key].$isMongooseDocumentArray || from[key].$isMongooseDocumentArray && to[key].$isSingleNested || from[key].$isMongooseDocumentArrayElement && to[key].$isMongooseDocumentArrayElement) {\n          continue;\n        } else if (from[key].instanceOfSchema) {\n          if (to[key].instanceOfSchema) {\n            schemaMerge(to[key], from[key].clone(), true);\n          } else {\n            to[key] = from[key].clone();\n          }\n          continue;\n        } else if (isBsonType(from[key], 'ObjectId')) {\n          to[key] = new ObjectId(from[key]);\n          continue;\n        }\n      }\n      mergeDiscriminatorSchema(to[key], from[key], path ? path + '.' + key : key, seen);\n    }\n  }\n  if (from != null && from.instanceOfSchema) {\n    to.tree = Object.assign({}, from.tree, to.tree);\n  }\n};","map":{"version":3,"names":["schemaMerge","require","specialProperties","isBsonType","ObjectId","isObject","module","exports","mergeDiscriminatorSchema","to","from","path","seen","keys","Object","i","len","length","key","WeakSet","has","add","instanceOfSchema","$isSingleNested","$isMongooseDocumentArray","$isMongooseDocumentArrayElement","clone","tree","assign"],"sources":["C:/Users/lrmir/OneDrive/Desktop/cs35L/newFridayz/Fridayz/frontend/node_modules/mongoose/lib/helpers/discriminator/mergeDiscriminatorSchema.js"],"sourcesContent":["'use strict';\nconst schemaMerge = require('../schema/merge');\nconst specialProperties = require('../../helpers/specialProperties');\nconst isBsonType = require('../../helpers/isBsonType');\nconst ObjectId = require('../../types/objectid');\nconst isObject = require('../../helpers/isObject');\n/**\n * Merges `from` into `to` without overwriting existing properties.\n *\n * @param {Object} to\n * @param {Object} from\n * @param {String} [path]\n * @api private\n */\n\nmodule.exports = function mergeDiscriminatorSchema(to, from, path, seen) {\n  const keys = Object.keys(from);\n  let i = 0;\n  const len = keys.length;\n  let key;\n\n  path = path || '';\n  seen = seen || new WeakSet();\n\n  if (seen.has(from)) {\n    return;\n  }\n  seen.add(from);\n\n  while (i < len) {\n    key = keys[i++];\n    if (!path) {\n      if (key === 'discriminators' ||\n        key === 'base' ||\n        key === '_applyDiscriminators' ||\n        key === '_userProvidedOptions' ||\n        key === 'options' ||\n        key === 'tree') {\n        continue;\n      }\n    }\n    if (path === 'tree' && from != null && from.instanceOfSchema) {\n      continue;\n    }\n    if (specialProperties.has(key)) {\n      continue;\n    }\n    if (to[key] == null) {\n      to[key] = from[key];\n    } else if (isObject(from[key])) {\n      if (!isObject(to[key])) {\n        to[key] = {};\n      }\n      if (from[key] != null) {\n        // Skip merging schemas if we're creating a discriminator schema and\n        // base schema has a given path as a single nested but discriminator schema\n        // has the path as a document array, or vice versa (gh-9534)\n        if ((from[key].$isSingleNested && to[key].$isMongooseDocumentArray) ||\n              (from[key].$isMongooseDocumentArray && to[key].$isSingleNested) ||\n              (from[key].$isMongooseDocumentArrayElement && to[key].$isMongooseDocumentArrayElement)) {\n          continue;\n        } else if (from[key].instanceOfSchema) {\n          if (to[key].instanceOfSchema) {\n            schemaMerge(to[key], from[key].clone(), true);\n          } else {\n            to[key] = from[key].clone();\n          }\n          continue;\n        } else if (isBsonType(from[key], 'ObjectId')) {\n          to[key] = new ObjectId(from[key]);\n          continue;\n        }\n      }\n      mergeDiscriminatorSchema(to[key], from[key], path ? path + '.' + key : key, seen);\n    }\n  }\n\n  if (from != null && from.instanceOfSchema) {\n    to.tree = Object.assign({}, from.tree, to.tree);\n  }\n};\n"],"mappings":"AAAA,YAAY;;AACZ,MAAMA,WAAW,GAAGC,OAAO,CAAC,iBAAiB,CAAC;AAC9C,MAAMC,iBAAiB,GAAGD,OAAO,CAAC,iCAAiC,CAAC;AACpE,MAAME,UAAU,GAAGF,OAAO,CAAC,0BAA0B,CAAC;AACtD,MAAMG,QAAQ,GAAGH,OAAO,CAAC,sBAAsB,CAAC;AAChD,MAAMI,QAAQ,GAAGJ,OAAO,CAAC,wBAAwB,CAAC;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAK,MAAM,CAACC,OAAO,GAAG,SAASC,wBAAwBA,CAACC,EAAE,EAAEC,IAAI,EAAEC,IAAI,EAAEC,IAAI,EAAE;EACvE,MAAMC,IAAI,GAAGC,MAAM,CAACD,IAAI,CAACH,IAAI,CAAC;EAC9B,IAAIK,CAAC,GAAG,CAAC;EACT,MAAMC,GAAG,GAAGH,IAAI,CAACI,MAAM;EACvB,IAAIC,GAAG;EAEPP,IAAI,GAAGA,IAAI,IAAI,EAAE;EACjBC,IAAI,GAAGA,IAAI,IAAI,IAAIO,OAAO,CAAC,CAAC;EAE5B,IAAIP,IAAI,CAACQ,GAAG,CAACV,IAAI,CAAC,EAAE;IAClB;EACF;EACAE,IAAI,CAACS,GAAG,CAACX,IAAI,CAAC;EAEd,OAAOK,CAAC,GAAGC,GAAG,EAAE;IACdE,GAAG,GAAGL,IAAI,CAACE,CAAC,EAAE,CAAC;IACf,IAAI,CAACJ,IAAI,EAAE;MACT,IAAIO,GAAG,KAAK,gBAAgB,IAC1BA,GAAG,KAAK,MAAM,IACdA,GAAG,KAAK,sBAAsB,IAC9BA,GAAG,KAAK,sBAAsB,IAC9BA,GAAG,KAAK,SAAS,IACjBA,GAAG,KAAK,MAAM,EAAE;QAChB;MACF;IACF;IACA,IAAIP,IAAI,KAAK,MAAM,IAAID,IAAI,IAAI,IAAI,IAAIA,IAAI,CAACY,gBAAgB,EAAE;MAC5D;IACF;IACA,IAAIpB,iBAAiB,CAACkB,GAAG,CAACF,GAAG,CAAC,EAAE;MAC9B;IACF;IACA,IAAIT,EAAE,CAACS,GAAG,CAAC,IAAI,IAAI,EAAE;MACnBT,EAAE,CAACS,GAAG,CAAC,GAAGR,IAAI,CAACQ,GAAG,CAAC;IACrB,CAAC,MAAM,IAAIb,QAAQ,CAACK,IAAI,CAACQ,GAAG,CAAC,CAAC,EAAE;MAC9B,IAAI,CAACb,QAAQ,CAACI,EAAE,CAACS,GAAG,CAAC,CAAC,EAAE;QACtBT,EAAE,CAACS,GAAG,CAAC,GAAG,CAAC,CAAC;MACd;MACA,IAAIR,IAAI,CAACQ,GAAG,CAAC,IAAI,IAAI,EAAE;QACrB;QACA;QACA;QACA,IAAKR,IAAI,CAACQ,GAAG,CAAC,CAACK,eAAe,IAAId,EAAE,CAACS,GAAG,CAAC,CAACM,wBAAwB,IAC3Dd,IAAI,CAACQ,GAAG,CAAC,CAACM,wBAAwB,IAAIf,EAAE,CAACS,GAAG,CAAC,CAACK,eAAgB,IAC9Db,IAAI,CAACQ,GAAG,CAAC,CAACO,+BAA+B,IAAIhB,EAAE,CAACS,GAAG,CAAC,CAACO,+BAAgC,EAAE;UAC5F;QACF,CAAC,MAAM,IAAIf,IAAI,CAACQ,GAAG,CAAC,CAACI,gBAAgB,EAAE;UACrC,IAAIb,EAAE,CAACS,GAAG,CAAC,CAACI,gBAAgB,EAAE;YAC5BtB,WAAW,CAACS,EAAE,CAACS,GAAG,CAAC,EAAER,IAAI,CAACQ,GAAG,CAAC,CAACQ,KAAK,CAAC,CAAC,EAAE,IAAI,CAAC;UAC/C,CAAC,MAAM;YACLjB,EAAE,CAACS,GAAG,CAAC,GAAGR,IAAI,CAACQ,GAAG,CAAC,CAACQ,KAAK,CAAC,CAAC;UAC7B;UACA;QACF,CAAC,MAAM,IAAIvB,UAAU,CAACO,IAAI,CAACQ,GAAG,CAAC,EAAE,UAAU,CAAC,EAAE;UAC5CT,EAAE,CAACS,GAAG,CAAC,GAAG,IAAId,QAAQ,CAACM,IAAI,CAACQ,GAAG,CAAC,CAAC;UACjC;QACF;MACF;MACAV,wBAAwB,CAACC,EAAE,CAACS,GAAG,CAAC,EAAER,IAAI,CAACQ,GAAG,CAAC,EAAEP,IAAI,GAAGA,IAAI,GAAG,GAAG,GAAGO,GAAG,GAAGA,GAAG,EAAEN,IAAI,CAAC;IACnF;EACF;EAEA,IAAIF,IAAI,IAAI,IAAI,IAAIA,IAAI,CAACY,gBAAgB,EAAE;IACzCb,EAAE,CAACkB,IAAI,GAAGb,MAAM,CAACc,MAAM,CAAC,CAAC,CAAC,EAAElB,IAAI,CAACiB,IAAI,EAAElB,EAAE,CAACkB,IAAI,CAAC;EACjD;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}