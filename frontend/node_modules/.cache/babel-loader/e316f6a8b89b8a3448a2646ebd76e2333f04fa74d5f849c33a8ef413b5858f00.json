{"ast":null,"code":"'use strict';\n\n/*!\n * Module dependencies.\n */\nconst CastError = require('./error/cast');\nconst StrictModeError = require('./error/strict');\nconst Types = require('./schema/index');\nconst cast$expr = require('./helpers/query/cast$expr');\nconst castTextSearch = require('./schema/operators/text');\nconst get = require('./helpers/get');\nconst getSchemaDiscriminatorByValue = require('./helpers/discriminator/getSchemaDiscriminatorByValue');\nconst isOperator = require('./helpers/query/isOperator');\nconst util = require('util');\nconst isObject = require('./helpers/isObject');\nconst isMongooseObject = require('./helpers/isMongooseObject');\nconst utils = require('./utils');\nconst ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n\n/**\n * Handles internal casting for query filters.\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @param {Object} [options] the query options\n * @param {Boolean|\"throw\"} [options.strict] Wheter to enable all strict options\n * @param {Boolean|\"throw\"} [options.strictQuery] Enable strict Queries\n * @param {Boolean} [options.upsert]\n * @param {Query} [context] passed to setters\n * @api private\n */\nmodule.exports = function cast(schema, obj, options, context) {\n  if (Array.isArray(obj)) {\n    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));\n  }\n  if (obj == null) {\n    return obj;\n  }\n  if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;\n  }\n  const paths = Object.keys(obj);\n  let i = paths.length;\n  let _keys;\n  let any$conditionals;\n  let schematype;\n  let nested;\n  let path;\n  let type;\n  let val;\n  options = options || {};\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      if (!Array.isArray(val)) {\n        throw new CastError('Array', val, path);\n      }\n      for (let k = 0; k < val.length; ++k) {\n        if (val[k] == null || typeof val[k] !== 'object') {\n          throw new CastError('Object', val[k], path + '.' + k);\n        }\n        const discriminatorValue = val[k][schema.options.discriminatorKey];\n        if (discriminatorValue == null) {\n          val[k] = cast(schema, val[k], options, context);\n        } else {\n          const discriminatorSchema = getSchemaDiscriminatorByValue(context.schema, discriminatorValue);\n          val[k] = cast(discriminatorSchema ? discriminatorSchema : schema, val[k], options, context);\n        }\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n      continue;\n    } else if (path === '$expr') {\n      val = cast$expr(val, schema);\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val, options, context);\n    } else if (path === '$text') {\n      val = castTextSearch(val, path);\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n      schematype = schema.path(path);\n\n      // Check for embedded discriminator paths\n      if (!schematype) {\n        const split = path.split('.');\n        let j = split.length;\n        while (j--) {\n          const pathFirstHalf = split.slice(0, j).join('.');\n          const pathLastHalf = split.slice(j).join('.');\n          const _schematype = schema.path(pathFirstHalf);\n          const discriminatorKey = _schematype && _schematype.schema && _schematype.schema.options && _schematype.schema.options.discriminatorKey;\n\n          // gh-6027: if we haven't found the schematype but this path is\n          // underneath an embedded discriminator and the embedded discriminator\n          // key is in the query, use the embedded discriminator schema\n          if (_schematype != null && (_schematype.schema && _schematype.schema.discriminators) != null && discriminatorKey != null && pathLastHalf !== discriminatorKey) {\n            const discriminatorVal = get(obj, pathFirstHalf + '.' + discriminatorKey);\n            const discriminators = _schematype.schema.discriminators;\n            if (typeof discriminatorVal === 'string' && discriminators[discriminatorVal] != null) {\n              schematype = discriminators[discriminatorVal].path(pathLastHalf);\n            } else if (discriminatorVal != null && Object.keys(discriminatorVal).length === 1 && Array.isArray(discriminatorVal.$in) && discriminatorVal.$in.length === 1 && typeof discriminatorVal.$in[0] === 'string' && discriminators[discriminatorVal.$in[0]] != null) {\n              schematype = discriminators[discriminatorVal.$in[0]].path(pathLastHalf);\n            }\n          }\n        }\n      }\n      if (!schematype) {\n        // Handle potential embedded array queries\n        const split = path.split('.');\n        let j = split.length;\n        let pathFirstHalf;\n        let pathLastHalf;\n        let remainingConds;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) {\n            break;\n          }\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n            const ret = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];\n            if (ret === void 0) {\n              delete obj[path];\n            } else {\n              obj[path] = ret;\n            }\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n        if (isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          let geo = '';\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n          if (geo) {\n            const numbertype = new Types.Number('__QueryCasting__');\n            let value = val[geo];\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQuery(null, val.$maxDistance, context);\n            }\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQuery(null, val.$minDistance, context);\n            }\n            if (geo === '$within') {\n              const withinType = value.$center || value.$centerSphere || value.$box || value.$polygon;\n              if (!withinType) {\n                throw new Error('Bad $within parameter: ' + JSON.stringify(val));\n              }\n              value = withinType;\n            } else if (geo === '$near' && typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') && value.$geometry && typeof value.$geometry.type === 'string' && Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQuery(null, value.$maxDistance, context);\n              }\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQuery(null, value.$minDistance, context);\n              }\n              if (isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({\n                    virtuals: false\n                  });\n                }\n                const geoWithinType = value.$geometry.type;\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' + geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center || value.$centerSphere;\n                if (isMongooseObject(value)) {\n                  value = value.toObject({\n                    virtuals: false\n                  });\n                }\n              }\n            }\n            _cast(value, numbertype, context);\n            continue;\n          }\n        }\n        if (schema.nested[path]) {\n          continue;\n        }\n        const strict = 'strict' in options ? options.strict : schema.options.strict;\n        const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);\n        if (options.upsert && strict) {\n          if (strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' + 'schema, strict mode is `true`, and upsert is `true`.');\n        }\n        if (strictQuery === 'throw') {\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' + 'schema and strictQuery is \\'throw\\'.');\n        } else if (strictQuery) {\n          delete obj[path];\n        }\n      } else if (val == null) {\n        continue;\n      } else if (utils.isPOJO(val)) {\n        any$conditionals = Object.keys(val).some(isOperator);\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQuery(null, val, context);\n        } else {\n          const ks = Object.keys(val);\n          let $cond;\n          let k = ks.length;\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n            if ($cond === '$elemMatch') {\n              if (nested && schematype != null && schematype.schema != null) {\n                cast(schematype.schema, nested, options, context);\n              } else if (nested && schematype != null && schematype.$isMongooseArray) {\n                if (utils.isPOJO(nested) && nested.$not != null) {\n                  cast(schema, nested, options, context);\n                } else {\n                  val[$cond] = schematype.castForQuery($cond, nested, context);\n                }\n              }\n            } else if ($cond === '$not') {\n              if (nested && schematype) {\n                _keys = Object.keys(nested);\n                if (_keys.length && isOperator(_keys[0])) {\n                  for (const key in nested) {\n                    nested[key] = schematype.castForQuery(key, nested[key], context);\n                  }\n                } else {\n                  val[$cond] = schematype.castForQuery($cond, nested, context);\n                }\n                continue;\n              }\n            } else {\n              val[$cond] = schematype.castForQuery($cond, nested, context);\n            }\n          }\n        }\n      } else if (Array.isArray(val) && ['Buffer', 'Array'].indexOf(schematype.instance) === -1) {\n        const casted = [];\n        const valuesArray = val;\n        for (const _val of valuesArray) {\n          casted.push(schematype.castForQuery(null, _val, context));\n        }\n        obj[path] = {\n          $in: casted\n        };\n      } else {\n        obj[path] = schematype.castForQuery(null, val, context);\n      }\n    }\n  }\n  return obj;\n};\nfunction _cast(val, numbertype, context) {\n  if (Array.isArray(val)) {\n    val.forEach(function (item, i) {\n      if (Array.isArray(item) || isObject(item)) {\n        return _cast(item, numbertype, context);\n      }\n      val[i] = numbertype.castForQuery(null, item, context);\n    });\n  } else {\n    const nearKeys = Object.keys(val);\n    let nearLen = nearKeys.length;\n    while (nearLen--) {\n      const nkey = nearKeys[nearLen];\n      const item = val[nkey];\n      if (Array.isArray(item) || isObject(item)) {\n        _cast(item, numbertype, context);\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery({\n          val: item,\n          context: context\n        });\n      }\n    }\n  }\n}\nfunction getStrictQuery(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {\n  if ('strictQuery' in queryOptions) {\n    return queryOptions.strictQuery;\n  }\n  if ('strictQuery' in schemaUserProvidedOptions) {\n    return schemaUserProvidedOptions.strictQuery;\n  }\n  const mongooseOptions = context && context.mongooseCollection && context.mongooseCollection.conn && context.mongooseCollection.conn.base && context.mongooseCollection.conn.base.options;\n  if (mongooseOptions) {\n    if ('strictQuery' in mongooseOptions) {\n      return mongooseOptions.strictQuery;\n    }\n  }\n  return schemaOptions.strictQuery;\n}","map":{"version":3,"names":["CastError","require","StrictModeError","Types","cast$expr","castTextSearch","get","getSchemaDiscriminatorByValue","isOperator","util","isObject","isMongooseObject","utils","ALLOWED_GEOWITHIN_GEOJSON_TYPES","module","exports","cast","schema","obj","options","context","Array","isArray","Error","inspect","discriminators","discriminatorKey","paths","Object","keys","i","length","_keys","any$conditionals","schematype","nested","path","type","val","k","discriminatorValue","discriminatorSchema","toString","split","j","pathFirstHalf","slice","join","pathLastHalf","_schematype","discriminatorVal","$in","remainingConds","caster","ret","geo","$near","$nearSphere","$within","$geoIntersects","$geoWithin","numbertype","Number","value","$maxDistance","castForQuery","$minDistance","withinType","$center","$centerSphere","$box","$polygon","JSON","stringify","coordinates","$geometry","toObject","transform","virtuals","geoWithinType","indexOf","_cast","strict","strictQuery","getStrictQuery","_userProvidedOptions","upsert","isPOJO","some","ks","$cond","$isMongooseArray","$not","key","instance","casted","valuesArray","_val","push","forEach","item","nearKeys","nearLen","nkey","queryOptions","schemaUserProvidedOptions","schemaOptions","mongooseOptions","mongooseCollection","conn","base"],"sources":["C:/Users/lrmir/OneDrive/Desktop/cs35L/newFridayz/Fridayz/frontend/node_modules/mongoose/lib/cast.js"],"sourcesContent":["'use strict';\n\n/*!\n * Module dependencies.\n */\n\nconst CastError = require('./error/cast');\nconst StrictModeError = require('./error/strict');\nconst Types = require('./schema/index');\nconst cast$expr = require('./helpers/query/cast$expr');\nconst castTextSearch = require('./schema/operators/text');\nconst get = require('./helpers/get');\nconst getSchemaDiscriminatorByValue = require('./helpers/discriminator/getSchemaDiscriminatorByValue');\nconst isOperator = require('./helpers/query/isOperator');\nconst util = require('util');\nconst isObject = require('./helpers/isObject');\nconst isMongooseObject = require('./helpers/isMongooseObject');\nconst utils = require('./utils');\n\nconst ALLOWED_GEOWITHIN_GEOJSON_TYPES = ['Polygon', 'MultiPolygon'];\n\n/**\n * Handles internal casting for query filters.\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @param {Object} [options] the query options\n * @param {Boolean|\"throw\"} [options.strict] Wheter to enable all strict options\n * @param {Boolean|\"throw\"} [options.strictQuery] Enable strict Queries\n * @param {Boolean} [options.upsert]\n * @param {Query} [context] passed to setters\n * @api private\n */\nmodule.exports = function cast(schema, obj, options, context) {\n  if (Array.isArray(obj)) {\n    throw new Error('Query filter must be an object, got an array ', util.inspect(obj));\n  }\n\n  if (obj == null) {\n    return obj;\n  }\n\n  if (schema != null && schema.discriminators != null && obj[schema.options.discriminatorKey] != null) {\n    schema = getSchemaDiscriminatorByValue(schema, obj[schema.options.discriminatorKey]) || schema;\n  }\n\n  const paths = Object.keys(obj);\n  let i = paths.length;\n  let _keys;\n  let any$conditionals;\n  let schematype;\n  let nested;\n  let path;\n  let type;\n  let val;\n\n  options = options || {};\n\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      if (!Array.isArray(val)) {\n        throw new CastError('Array', val, path);\n      }\n      for (let k = 0; k < val.length; ++k) {\n        if (val[k] == null || typeof val[k] !== 'object') {\n          throw new CastError('Object', val[k], path + '.' + k);\n        }\n        const discriminatorValue = val[k][schema.options.discriminatorKey];\n        if (discriminatorValue == null) {\n          val[k] = cast(schema, val[k], options, context);\n        } else {\n          const discriminatorSchema = getSchemaDiscriminatorByValue(context.schema, discriminatorValue);\n          val[k] = cast(discriminatorSchema ? discriminatorSchema : schema, val[k], options, context);\n        }\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n\n      continue;\n    } else if (path === '$expr') {\n      val = cast$expr(val, schema);\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val, options, context);\n    } else if (path === '$text') {\n      val = castTextSearch(val, path);\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n\n      schematype = schema.path(path);\n\n      // Check for embedded discriminator paths\n      if (!schematype) {\n        const split = path.split('.');\n        let j = split.length;\n        while (j--) {\n          const pathFirstHalf = split.slice(0, j).join('.');\n          const pathLastHalf = split.slice(j).join('.');\n          const _schematype = schema.path(pathFirstHalf);\n          const discriminatorKey = _schematype &&\n            _schematype.schema &&\n            _schematype.schema.options &&\n            _schematype.schema.options.discriminatorKey;\n\n          // gh-6027: if we haven't found the schematype but this path is\n          // underneath an embedded discriminator and the embedded discriminator\n          // key is in the query, use the embedded discriminator schema\n          if (_schematype != null &&\n            (_schematype.schema && _schematype.schema.discriminators) != null &&\n            discriminatorKey != null &&\n            pathLastHalf !== discriminatorKey) {\n            const discriminatorVal = get(obj, pathFirstHalf + '.' + discriminatorKey);\n            const discriminators = _schematype.schema.discriminators;\n            if (typeof discriminatorVal === 'string' && discriminators[discriminatorVal] != null) {\n\n              schematype = discriminators[discriminatorVal].path(pathLastHalf);\n            } else if (discriminatorVal != null &&\n              Object.keys(discriminatorVal).length === 1 &&\n              Array.isArray(discriminatorVal.$in) &&\n              discriminatorVal.$in.length === 1 &&\n              typeof discriminatorVal.$in[0] === 'string' &&\n              discriminators[discriminatorVal.$in[0]] != null) {\n              schematype = discriminators[discriminatorVal.$in[0]].path(pathLastHalf);\n            }\n          }\n        }\n      }\n\n      if (!schematype) {\n        // Handle potential embedded array queries\n        const split = path.split('.');\n        let j = split.length;\n        let pathFirstHalf;\n        let pathLastHalf;\n        let remainingConds;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) {\n            break;\n          }\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n\n            const ret = cast(schematype.caster.schema, remainingConds, options, context)[pathLastHalf];\n            if (ret === void 0) {\n              delete obj[path];\n            } else {\n              obj[path] = ret;\n            }\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n\n        if (isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          let geo = '';\n          if (val.$near) {\n            geo = '$near';\n          } else if (val.$nearSphere) {\n            geo = '$nearSphere';\n          } else if (val.$within) {\n            geo = '$within';\n          } else if (val.$geoIntersects) {\n            geo = '$geoIntersects';\n          } else if (val.$geoWithin) {\n            geo = '$geoWithin';\n          }\n\n          if (geo) {\n            const numbertype = new Types.Number('__QueryCasting__');\n            let value = val[geo];\n\n            if (val.$maxDistance != null) {\n              val.$maxDistance = numbertype.castForQuery(\n                null,\n                val.$maxDistance,\n                context\n              );\n            }\n            if (val.$minDistance != null) {\n              val.$minDistance = numbertype.castForQuery(\n                null,\n                val.$minDistance,\n                context\n              );\n            }\n\n            if (geo === '$within') {\n              const withinType = value.$center\n                  || value.$centerSphere\n                  || value.$box\n                  || value.$polygon;\n\n              if (!withinType) {\n                throw new Error('Bad $within parameter: ' + JSON.stringify(val));\n              }\n\n              value = withinType;\n            } else if (geo === '$near' &&\n                typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n              // geojson; cast the coordinates\n              value = value.coordinates;\n            } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') &&\n                value.$geometry && typeof value.$geometry.type === 'string' &&\n                Array.isArray(value.$geometry.coordinates)) {\n              if (value.$maxDistance != null) {\n                value.$maxDistance = numbertype.castForQuery(\n                  null,\n                  value.$maxDistance,\n                  context\n                );\n              }\n              if (value.$minDistance != null) {\n                value.$minDistance = numbertype.castForQuery(\n                  null,\n                  value.$minDistance,\n                  context\n                );\n              }\n              if (isMongooseObject(value.$geometry)) {\n                value.$geometry = value.$geometry.toObject({\n                  transform: false,\n                  virtuals: false\n                });\n              }\n              value = value.$geometry.coordinates;\n            } else if (geo === '$geoWithin') {\n              if (value.$geometry) {\n                if (isMongooseObject(value.$geometry)) {\n                  value.$geometry = value.$geometry.toObject({ virtuals: false });\n                }\n                const geoWithinType = value.$geometry.type;\n                if (ALLOWED_GEOWITHIN_GEOJSON_TYPES.indexOf(geoWithinType) === -1) {\n                  throw new Error('Invalid geoJSON type for $geoWithin \"' +\n                    geoWithinType + '\", must be \"Polygon\" or \"MultiPolygon\"');\n                }\n                value = value.$geometry.coordinates;\n              } else {\n                value = value.$box || value.$polygon || value.$center ||\n                  value.$centerSphere;\n                if (isMongooseObject(value)) {\n                  value = value.toObject({ virtuals: false });\n                }\n              }\n            }\n\n            _cast(value, numbertype, context);\n            continue;\n          }\n        }\n\n        if (schema.nested[path]) {\n          continue;\n        }\n\n        const strict = 'strict' in options ? options.strict : schema.options.strict;\n        const strictQuery = getStrictQuery(options, schema._userProvidedOptions, schema.options, context);\n        if (options.upsert && strict) {\n          if (strict === 'throw') {\n            throw new StrictModeError(path);\n          }\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema, strict mode is `true`, and upsert is `true`.');\n        } if (strictQuery === 'throw') {\n          throw new StrictModeError(path, 'Path \"' + path + '\" is not in ' +\n            'schema and strictQuery is \\'throw\\'.');\n        } else if (strictQuery) {\n          delete obj[path];\n        }\n      } else if (val == null) {\n        continue;\n      } else if (utils.isPOJO(val)) {\n        any$conditionals = Object.keys(val).some(isOperator);\n\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQuery(\n            null,\n            val,\n            context\n          );\n        } else {\n          const ks = Object.keys(val);\n          let $cond;\n          let k = ks.length;\n\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n            if ($cond === '$elemMatch') {\n              if (nested && schematype != null && schematype.schema != null) {\n                cast(schematype.schema, nested, options, context);\n              } else if (nested && schematype != null && schematype.$isMongooseArray) {\n                if (utils.isPOJO(nested) && nested.$not != null) {\n                  cast(schema, nested, options, context);\n                } else {\n                  val[$cond] = schematype.castForQuery(\n                    $cond,\n                    nested,\n                    context\n                  );\n                }\n              }\n            } else if ($cond === '$not') {\n              if (nested && schematype) {\n                _keys = Object.keys(nested);\n                if (_keys.length && isOperator(_keys[0])) {\n                  for (const key in nested) {\n                    nested[key] = schematype.castForQuery(\n                      key,\n                      nested[key],\n                      context\n                    );\n                  }\n                } else {\n                  val[$cond] = schematype.castForQuery(\n                    $cond,\n                    nested,\n                    context\n                  );\n                }\n                continue;\n              }\n            } else {\n              val[$cond] = schematype.castForQuery(\n                $cond,\n                nested,\n                context\n              );\n            }\n\n          }\n        }\n      } else if (Array.isArray(val) && ['Buffer', 'Array'].indexOf(schematype.instance) === -1) {\n        const casted = [];\n        const valuesArray = val;\n\n        for (const _val of valuesArray) {\n          casted.push(schematype.castForQuery(\n            null,\n            _val,\n            context\n          ));\n        }\n\n        obj[path] = { $in: casted };\n      } else {\n        obj[path] = schematype.castForQuery(\n          null,\n          val,\n          context\n        );\n      }\n    }\n  }\n\n  return obj;\n};\n\nfunction _cast(val, numbertype, context) {\n  if (Array.isArray(val)) {\n    val.forEach(function(item, i) {\n      if (Array.isArray(item) || isObject(item)) {\n        return _cast(item, numbertype, context);\n      }\n      val[i] = numbertype.castForQuery(null, item, context);\n    });\n  } else {\n    const nearKeys = Object.keys(val);\n    let nearLen = nearKeys.length;\n    while (nearLen--) {\n      const nkey = nearKeys[nearLen];\n      const item = val[nkey];\n      if (Array.isArray(item) || isObject(item)) {\n        _cast(item, numbertype, context);\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery({ val: item, context: context });\n      }\n    }\n  }\n}\n\nfunction getStrictQuery(queryOptions, schemaUserProvidedOptions, schemaOptions, context) {\n  if ('strictQuery' in queryOptions) {\n    return queryOptions.strictQuery;\n  }\n  if ('strictQuery' in schemaUserProvidedOptions) {\n    return schemaUserProvidedOptions.strictQuery;\n  }\n  const mongooseOptions = context &&\n    context.mongooseCollection &&\n    context.mongooseCollection.conn &&\n    context.mongooseCollection.conn.base &&\n    context.mongooseCollection.conn.base.options;\n  if (mongooseOptions) {\n    if ('strictQuery' in mongooseOptions) {\n      return mongooseOptions.strictQuery;\n    }\n  }\n  return schemaOptions.strictQuery;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}