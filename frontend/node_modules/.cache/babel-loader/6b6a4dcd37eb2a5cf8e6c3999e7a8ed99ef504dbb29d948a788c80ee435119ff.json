{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.read = exports.readMany = exports.writeCommand = exports.readWireProtocolMessages = exports.ModernConnection = exports.hasSessionSupport = exports.CryptoConnection = exports.Connection = void 0;\nconst events_1 = require(\"events\");\nconst stream_1 = require(\"stream\");\nconst timers_1 = require(\"timers\");\nconst util_1 = require(\"util\");\nconst constants_1 = require(\"../constants\");\nconst error_1 = require(\"../error\");\nconst mongo_types_1 = require(\"../mongo_types\");\nconst sessions_1 = require(\"../sessions\");\nconst utils_1 = require(\"../utils\");\nconst command_monitoring_events_1 = require(\"./command_monitoring_events\");\nconst commands_1 = require(\"./commands\");\nconst message_stream_1 = require(\"./message_stream\");\nconst stream_description_1 = require(\"./stream_description\");\nconst compression_1 = require(\"./wire_protocol/compression\");\nconst shared_1 = require(\"./wire_protocol/shared\");\n/** @internal */\nconst kStream = Symbol('stream');\n/** @internal */\nconst kQueue = Symbol('queue');\n/** @internal */\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\nconst kGeneration = Symbol('generation');\n/** @internal */\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\nconst kDescription = Symbol('description');\n/** @internal */\nconst kHello = Symbol('hello');\n/** @internal */\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\nconst kDelayedTimeoutId = Symbol('delayedTimeoutId');\nconst INVALID_QUEUE_SIZE = 'Connection internal queue contains more than 1 operation description';\n/** @internal */\nclass Connection extends mongo_types_1.TypedEventEmitter {\n  constructor(stream, options) {\n    super();\n    this.commandAsync = (0, util_1.promisify)((ns, cmd, options, callback) => this.command(ns, cmd, options, callback));\n    this.id = options.id;\n    this.address = streamIdentifier(stream, options);\n    this.socketTimeoutMS = options.socketTimeoutMS ?? 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this[kHello] = null;\n    this[kClusterTime] = null;\n    this[kDescription] = new stream_description_1.StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = (0, utils_1.now)();\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new message_stream_1.MessageStream({\n      ...options,\n      maxBsonMessageSize: this.hello?.maxBsonMessageSize\n    });\n    this[kStream] = stream;\n    this[kDelayedTimeoutId] = null;\n    this[kMessageStream].on('message', message => this.onMessage(message));\n    this[kMessageStream].on('error', error => this.onError(error));\n    this[kStream].on('close', () => this.onClose());\n    this[kStream].on('timeout', () => this.onTimeout());\n    this[kStream].on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n    // hook the message stream up to the passed in stream\n    this[kStream].pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(this[kStream]);\n  }\n  get description() {\n    return this[kDescription];\n  }\n  get hello() {\n    return this[kHello];\n  }\n  // the `connect` method stores the result of the handshake hello on the connection\n  set hello(response) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]);\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kHello] = response;\n  }\n  // Set the whether the message stream is for a monitoring connection.\n  set isMonitoringConnection(value) {\n    this[kMessageStream].isMonitoringConnection = value;\n  }\n  get isMonitoringConnection() {\n    return this[kMessageStream].isMonitoringConnection;\n  }\n  get serviceId() {\n    return this.hello?.serviceId;\n  }\n  get loadBalanced() {\n    return this.description.loadBalanced;\n  }\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n  set generation(generation) {\n    this[kGeneration] = generation;\n  }\n  get idleTime() {\n    return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);\n  }\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n  get stream() {\n    return this[kStream];\n  }\n  markAvailable() {\n    this[kLastUseTime] = (0, utils_1.now)();\n  }\n  onError(error) {\n    this.cleanup(true, error);\n  }\n  onClose() {\n    const message = `connection ${this.id} to ${this.address} closed`;\n    this.cleanup(true, new error_1.MongoNetworkError(message));\n  }\n  onTimeout() {\n    this[kDelayedTimeoutId] = (0, timers_1.setTimeout)(() => {\n      const message = `connection ${this.id} to ${this.address} timed out`;\n      const beforeHandshake = this.hello == null;\n      this.cleanup(true, new error_1.MongoNetworkTimeoutError(message, {\n        beforeHandshake\n      }));\n    }, 1).unref(); // No need for this timer to hold the event loop open\n  }\n  onMessage(message) {\n    const delayedTimeoutId = this[kDelayedTimeoutId];\n    if (delayedTimeoutId != null) {\n      (0, timers_1.clearTimeout)(delayedTimeoutId);\n      this[kDelayedTimeoutId] = null;\n    }\n    const socketTimeoutMS = this[kStream].timeout ?? 0;\n    this[kStream].setTimeout(0);\n    // always emit the message, in case we are streaming\n    this.emit('message', message);\n    let operationDescription = this[kQueue].get(message.responseTo);\n    if (!operationDescription && this.isMonitoringConnection) {\n      // This is how we recover when the initial hello's requestId is not\n      // the responseTo when hello responses have been skipped:\n      // First check if the map is of invalid size\n      if (this[kQueue].size > 1) {\n        this.cleanup(true, new error_1.MongoRuntimeError(INVALID_QUEUE_SIZE));\n      } else {\n        // Get the first orphaned operation description.\n        const entry = this[kQueue].entries().next();\n        if (entry.value != null) {\n          const [requestId, orphaned] = entry.value;\n          // If the orphaned operation description exists then set it.\n          operationDescription = orphaned;\n          // Remove the entry with the bad request id from the queue.\n          this[kQueue].delete(requestId);\n        }\n      }\n    }\n    if (!operationDescription) {\n      return;\n    }\n    const callback = operationDescription.cb;\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n    this[kQueue].delete(message.responseTo);\n    if ('moreToCome' in message && message.moreToCome) {\n      // If the operation description check above does find an orphaned\n      // description and sets the operationDescription then this line will put one\n      // back in the queue with the correct requestId and will resolve not being able\n      // to find the next one via the responseTo of the next streaming hello.\n      this[kQueue].set(message.requestId, operationDescription);\n      this[kStream].setTimeout(socketTimeoutMS);\n    }\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        (0, sessions_1.updateSessionFromResponse)(session, document);\n      }\n      if (document.$clusterTime) {\n        this[kClusterTime] = document.$clusterTime;\n        this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n      if (document.writeConcernError) {\n        callback(new error_1.MongoWriteConcernError(document.writeConcernError, document), document);\n        return;\n      }\n      if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n        callback(new error_1.MongoServerError(document));\n        return;\n      }\n    }\n    callback(undefined, message.documents[0]);\n  }\n  destroy(options, callback) {\n    if (this.closed) {\n      process.nextTick(() => callback?.());\n      return;\n    }\n    if (typeof callback === 'function') {\n      this.once('close', () => process.nextTick(() => callback()));\n    }\n    // load balanced mode requires that these listeners remain on the connection\n    // after cleanup on timeouts, errors or close so we remove them before calling\n    // cleanup.\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n    const message = `connection ${this.id} to ${this.address} closed`;\n    this.cleanup(options.force, new error_1.MongoNetworkError(message));\n  }\n  /**\n   * A method that cleans up the connection.  When `force` is true, this method\n   * forcibly destroys the socket.\n   *\n   * If an error is provided, any in-flight operations will be closed with the error.\n   *\n   * This method does nothing if the connection is already closed.\n   */\n  cleanup(force, error) {\n    if (this.closed) {\n      return;\n    }\n    this.closed = true;\n    const completeCleanup = () => {\n      for (const op of this[kQueue].values()) {\n        op.cb(error);\n      }\n      this[kQueue].clear();\n      this.emit(Connection.CLOSE);\n    };\n    this[kStream].removeAllListeners();\n    this[kMessageStream].removeAllListeners();\n    this[kMessageStream].destroy();\n    if (force) {\n      this[kStream].destroy();\n      completeCleanup();\n      return;\n    }\n    if (!this[kStream].writableEnded) {\n      this[kStream].end(() => {\n        this[kStream].destroy();\n        completeCleanup();\n      });\n    } else {\n      completeCleanup();\n    }\n  }\n  command(ns, command, options, callback) {\n    let cmd = {\n      ...command\n    };\n    const readPreference = (0, shared_1.getReadPreference)(options);\n    const shouldUseOpMsg = supportsOpMsg(this);\n    const session = options?.session;\n    let clusterTime = this.clusterTime;\n    if (this.serverApi) {\n      const {\n        version,\n        strict,\n        deprecationErrors\n      } = this.serverApi;\n      cmd.apiVersion = version;\n      if (strict != null) cmd.apiStrict = strict;\n      if (deprecationErrors != null) cmd.apiDeprecationErrors = deprecationErrors;\n    }\n    if (hasSessionSupport(this) && session) {\n      if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n        clusterTime = session.clusterTime;\n      }\n      const err = (0, sessions_1.applySession)(session, cmd, options);\n      if (err) {\n        return callback(err);\n      }\n    } else if (session?.explicit) {\n      return callback(new error_1.MongoCompatibilityError('Current topology does not support sessions'));\n    }\n    // if we have a known cluster time, gossip it\n    if (clusterTime) {\n      cmd.$clusterTime = clusterTime;\n    }\n    if ((0, shared_1.isSharded)(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n      cmd = {\n        $query: cmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n    const commandOptions = Object.assign({\n      numberToSkip: 0,\n      numberToReturn: -1,\n      checkKeys: false,\n      // This value is not overridable\n      secondaryOk: readPreference.secondaryOk()\n    }, options);\n    const message = shouldUseOpMsg ? new commands_1.OpMsgRequest(ns.db, cmd, commandOptions) : new commands_1.OpQueryRequest(ns.db, cmd, commandOptions);\n    try {\n      write(this, message, commandOptions, callback);\n    } catch (err) {\n      callback(err);\n    }\n  }\n}\n/** @event */\nConnection.COMMAND_STARTED = constants_1.COMMAND_STARTED;\n/** @event */\nConnection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;\n/** @event */\nConnection.COMMAND_FAILED = constants_1.COMMAND_FAILED;\n/** @event */\nConnection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;\n/** @event */\nConnection.CLOSE = constants_1.CLOSE;\n/** @event */\nConnection.MESSAGE = constants_1.MESSAGE;\n/** @event */\nConnection.PINNED = constants_1.PINNED;\n/** @event */\nConnection.UNPINNED = constants_1.UNPINNED;\nexports.Connection = Connection;\n/** @internal */\nclass CryptoConnection extends Connection {\n  constructor(stream, options) {\n    super(stream, options);\n    this[kAutoEncrypter] = options.autoEncrypter;\n  }\n  /** @internal @override */\n  command(ns, cmd, options, callback) {\n    const autoEncrypter = this[kAutoEncrypter];\n    if (!autoEncrypter) {\n      return callback(new error_1.MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n    }\n    const serverWireVersion = (0, utils_1.maxWireVersion)(this);\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options, callback);\n    }\n    if (serverWireVersion < 8) {\n      callback(new error_1.MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2'));\n      return;\n    }\n    // Save sort or indexKeys based on the command being run\n    // the encrypt API serializes our JS objects to BSON to pass to the native code layer\n    // and then deserializes the encrypted result, the protocol level components\n    // of the command (ex. sort) are then converted to JS objects potentially losing\n    // import key order information. These fields are never encrypted so we can save the values\n    // from before the encryption and replace them after encryption has been performed\n    const sort = cmd.find || cmd.findAndModify ? cmd.sort : null;\n    const indexKeys = cmd.createIndexes ? cmd.indexes.map(index => index.key) : null;\n    autoEncrypter.encrypt(ns.toString(), cmd, options).then(encrypted => {\n      // Replace the saved values\n      if (sort != null && (cmd.find || cmd.findAndModify)) {\n        encrypted.sort = sort;\n      }\n      if (indexKeys != null && cmd.createIndexes) {\n        for (const [offset, index] of indexKeys.entries()) {\n          // @ts-expect-error `encrypted` is a generic \"command\", but we've narrowed for only `createIndexes` commands here\n          encrypted.indexes[offset].key = index;\n        }\n      }\n      super.command(ns, encrypted, options, (err, response) => {\n        if (err || response == null) {\n          callback(err, response);\n          return;\n        }\n        autoEncrypter.decrypt(response, options).then(res => callback(undefined, res), err => callback(err));\n      });\n    }, err => {\n      if (err) {\n        callback(err, null);\n      }\n    });\n  }\n}\nexports.CryptoConnection = CryptoConnection;\n/** @internal */\nfunction hasSessionSupport(conn) {\n  const description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null;\n}\nexports.hasSessionSupport = hasSessionSupport;\nfunction supportsOpMsg(conn) {\n  const description = conn.description;\n  if (description == null) {\n    return false;\n  }\n  return (0, utils_1.maxWireVersion)(conn) >= 6 && !description.__nodejs_mock_server__;\n}\nfunction streamIdentifier(stream, options) {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n  const {\n    remoteAddress,\n    remotePort\n  } = stream;\n  if (typeof remoteAddress === 'string' && typeof remotePort === 'number') {\n    return utils_1.HostAddress.fromHostPort(remoteAddress, remotePort).toString();\n  }\n  return (0, utils_1.uuidV4)().toString('hex');\n}\nfunction write(conn, command, options, callback) {\n  options = options ?? {};\n  const operationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n    // for BSON parsing\n    useBigInt64: typeof options.useBigInt64 === 'boolean' ? options.useBigInt64 : false,\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation: typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n  if (typeof options.socketTimeoutMS === 'number') {\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  } else if (conn.socketTimeoutMS !== 0) {\n    conn[kStream].setTimeout(conn.socketTimeoutMS);\n  }\n  // if command monitoring is enabled we need to modify the callback here\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new command_monitoring_events_1.CommandStartedEvent(conn, command));\n    operationDescription.started = (0, utils_1.now)();\n    operationDescription.cb = (err, reply) => {\n      // Command monitoring spec states that if ok is 1, then we must always emit\n      // a command succeeded event, even if there's an error. Write concern errors\n      // will have an ok: 1 in their reply.\n      if (err && reply?.ok !== 1) {\n        conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, err, operationDescription.started));\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(Connection.COMMAND_FAILED, new command_monitoring_events_1.CommandFailedEvent(conn, command, reply, operationDescription.started));\n        } else {\n          conn.emit(Connection.COMMAND_SUCCEEDED, new command_monitoring_events_1.CommandSucceededEvent(conn, command, reply, operationDescription.started));\n        }\n      }\n      if (typeof callback === 'function') {\n        // Since we're passing through the reply with the write concern error now, we\n        // need it not to be provided to the original callback in this case so\n        // retryability does not get tricked into thinking the command actually\n        // succeeded.\n        callback(err, err instanceof error_1.MongoWriteConcernError ? undefined : reply);\n      }\n    };\n  }\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n/** in-progress connection layer */\n/** @internal */\nclass ModernConnection extends mongo_types_1.TypedEventEmitter {\n  constructor(stream, options) {\n    super();\n    this.commandAsync = (0, util_1.promisify)((ns, cmd, options, callback) => this.command(ns, cmd, options, callback));\n    this.id = options.id;\n    this.address = streamIdentifier(stream, options);\n    this.socketTimeoutMS = options.socketTimeoutMS ?? 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this[kHello] = null;\n    this[kClusterTime] = null;\n    this[kDescription] = new stream_description_1.StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = (0, utils_1.now)();\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new message_stream_1.MessageStream({\n      ...options,\n      maxBsonMessageSize: this.hello?.maxBsonMessageSize\n    });\n    this.socket = stream;\n    this[kDelayedTimeoutId] = null;\n    this[kMessageStream].on('message', message => this.onMessage(message));\n    this[kMessageStream].on('error', error => this.onError(error));\n    this.socket.on('close', () => this.onClose());\n    this.socket.on('timeout', () => this.onTimeout());\n    this.socket.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n    // hook the message stream up to the passed in stream\n    this.socket.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(this.socket);\n  }\n  get description() {\n    return this[kDescription];\n  }\n  get hello() {\n    return this[kHello];\n  }\n  // the `connect` method stores the result of the handshake hello on the connection\n  set hello(response) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]);\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kHello] = response;\n  }\n  // Set the whether the message stream is for a monitoring connection.\n  set isMonitoringConnection(value) {\n    this[kMessageStream].isMonitoringConnection = value;\n  }\n  get isMonitoringConnection() {\n    return this[kMessageStream].isMonitoringConnection;\n  }\n  get serviceId() {\n    return this.hello?.serviceId;\n  }\n  get loadBalanced() {\n    return this.description.loadBalanced;\n  }\n  get generation() {\n    return this[kGeneration] || 0;\n  }\n  set generation(generation) {\n    this[kGeneration] = generation;\n  }\n  get idleTime() {\n    return (0, utils_1.calculateDurationInMs)(this[kLastUseTime]);\n  }\n  get clusterTime() {\n    return this[kClusterTime];\n  }\n  get stream() {\n    return this.socket;\n  }\n  get hasSessionSupport() {\n    return this.description.logicalSessionTimeoutMinutes != null;\n  }\n  get supportsOpMsg() {\n    return this.description != null && (0, utils_1.maxWireVersion)(this) >= 6 && !this.description.__nodejs_mock_server__;\n  }\n  markAvailable() {\n    this[kLastUseTime] = (0, utils_1.now)();\n  }\n  onError(error) {\n    this.cleanup(true, error);\n  }\n  onClose() {\n    const message = `connection ${this.id} to ${this.address} closed`;\n    this.cleanup(true, new error_1.MongoNetworkError(message));\n  }\n  onTimeout() {\n    this[kDelayedTimeoutId] = (0, timers_1.setTimeout)(() => {\n      const message = `connection ${this.id} to ${this.address} timed out`;\n      const beforeHandshake = this.hello == null;\n      this.cleanup(true, new error_1.MongoNetworkTimeoutError(message, {\n        beforeHandshake\n      }));\n    }, 1).unref(); // No need for this timer to hold the event loop open\n  }\n  onMessage(message) {\n    const delayedTimeoutId = this[kDelayedTimeoutId];\n    if (delayedTimeoutId != null) {\n      (0, timers_1.clearTimeout)(delayedTimeoutId);\n      this[kDelayedTimeoutId] = null;\n    }\n    const socketTimeoutMS = this.socket.timeout ?? 0;\n    this.socket.setTimeout(0);\n    // always emit the message, in case we are streaming\n    this.emit('message', message);\n    let operationDescription = this[kQueue].get(message.responseTo);\n    if (!operationDescription && this.isMonitoringConnection) {\n      // This is how we recover when the initial hello's requestId is not\n      // the responseTo when hello responses have been skipped:\n      // First check if the map is of invalid size\n      if (this[kQueue].size > 1) {\n        this.cleanup(true, new error_1.MongoRuntimeError(INVALID_QUEUE_SIZE));\n      } else {\n        // Get the first orphaned operation description.\n        const entry = this[kQueue].entries().next();\n        if (entry.value != null) {\n          const [requestId, orphaned] = entry.value;\n          // If the orphaned operation description exists then set it.\n          operationDescription = orphaned;\n          // Remove the entry with the bad request id from the queue.\n          this[kQueue].delete(requestId);\n        }\n      }\n    }\n    if (!operationDescription) {\n      return;\n    }\n    const callback = operationDescription.cb;\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n    this[kQueue].delete(message.responseTo);\n    if ('moreToCome' in message && message.moreToCome) {\n      // If the operation description check above does find an orphaned\n      // description and sets the operationDescription then this line will put one\n      // back in the queue with the correct requestId and will resolve not being able\n      // to find the next one via the responseTo of the next streaming hello.\n      this[kQueue].set(message.requestId, operationDescription);\n      this.socket.setTimeout(socketTimeoutMS);\n    }\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n    if (message.documents[0]) {\n      const document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        (0, sessions_1.updateSessionFromResponse)(session, document);\n      }\n      if (document.$clusterTime) {\n        this[kClusterTime] = document.$clusterTime;\n        this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n      if (document.writeConcernError) {\n        callback(new error_1.MongoWriteConcernError(document.writeConcernError, document), document);\n        return;\n      }\n      if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n        callback(new error_1.MongoServerError(document));\n        return;\n      }\n    }\n    callback(undefined, message.documents[0]);\n  }\n  destroy(options, callback) {\n    if (this.closed) {\n      process.nextTick(() => callback?.());\n      return;\n    }\n    if (typeof callback === 'function') {\n      this.once('close', () => process.nextTick(() => callback()));\n    }\n    // load balanced mode requires that these listeners remain on the connection\n    // after cleanup on timeouts, errors or close so we remove them before calling\n    // cleanup.\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n    const message = `connection ${this.id} to ${this.address} closed`;\n    this.cleanup(options.force, new error_1.MongoNetworkError(message));\n  }\n  /**\n   * A method that cleans up the connection.  When `force` is true, this method\n   * forcibly destroys the socket.\n   *\n   * If an error is provided, any in-flight operations will be closed with the error.\n   *\n   * This method does nothing if the connection is already closed.\n   */\n  cleanup(force, error) {\n    if (this.closed) {\n      return;\n    }\n    this.closed = true;\n    const completeCleanup = () => {\n      for (const op of this[kQueue].values()) {\n        op.cb(error);\n      }\n      this[kQueue].clear();\n      this.emit(Connection.CLOSE);\n    };\n    this.socket.removeAllListeners();\n    this[kMessageStream].removeAllListeners();\n    this[kMessageStream].destroy();\n    if (force) {\n      this.socket.destroy();\n      completeCleanup();\n      return;\n    }\n    if (!this.socket.writableEnded) {\n      this.socket.end(() => {\n        this.socket.destroy();\n        completeCleanup();\n      });\n    } else {\n      completeCleanup();\n    }\n  }\n  command(ns, command, options, callback) {\n    let cmd = {\n      ...command\n    };\n    const readPreference = (0, shared_1.getReadPreference)(options);\n    const session = options?.session;\n    let clusterTime = this.clusterTime;\n    if (this.serverApi) {\n      const {\n        version,\n        strict,\n        deprecationErrors\n      } = this.serverApi;\n      cmd.apiVersion = version;\n      if (strict != null) cmd.apiStrict = strict;\n      if (deprecationErrors != null) cmd.apiDeprecationErrors = deprecationErrors;\n    }\n    if (this.hasSessionSupport && session) {\n      if (session.clusterTime && clusterTime && session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)) {\n        clusterTime = session.clusterTime;\n      }\n      const err = (0, sessions_1.applySession)(session, cmd, options);\n      if (err) {\n        return callback(err);\n      }\n    } else if (session?.explicit) {\n      return callback(new error_1.MongoCompatibilityError('Current topology does not support sessions'));\n    }\n    // if we have a known cluster time, gossip it\n    if (clusterTime) {\n      cmd.$clusterTime = clusterTime;\n    }\n    if (\n    // @ts-expect-error ModernConnections cannot be passed as connections\n    (0, shared_1.isSharded)(this) && !this.supportsOpMsg && readPreference && readPreference.mode !== 'primary') {\n      cmd = {\n        $query: cmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n    const commandOptions = Object.assign({\n      numberToSkip: 0,\n      numberToReturn: -1,\n      checkKeys: false,\n      // This value is not overridable\n      secondaryOk: readPreference.secondaryOk()\n    }, options);\n    const message = this.supportsOpMsg ? new commands_1.OpMsgRequest(ns.db, cmd, commandOptions) : new commands_1.OpQueryRequest(ns.db, cmd, commandOptions);\n    try {\n      write(this, message, commandOptions, callback);\n    } catch (err) {\n      callback(err);\n    }\n  }\n}\n/** @event */\nModernConnection.COMMAND_STARTED = constants_1.COMMAND_STARTED;\n/** @event */\nModernConnection.COMMAND_SUCCEEDED = constants_1.COMMAND_SUCCEEDED;\n/** @event */\nModernConnection.COMMAND_FAILED = constants_1.COMMAND_FAILED;\n/** @event */\nModernConnection.CLUSTER_TIME_RECEIVED = constants_1.CLUSTER_TIME_RECEIVED;\n/** @event */\nModernConnection.CLOSE = constants_1.CLOSE;\n/** @event */\nModernConnection.MESSAGE = constants_1.MESSAGE;\n/** @event */\nModernConnection.PINNED = constants_1.PINNED;\n/** @event */\nModernConnection.UNPINNED = constants_1.UNPINNED;\nexports.ModernConnection = ModernConnection;\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\n/**\n * @internal\n *\n * This helper reads chucks of data out of a socket and buffers them until it has received a\n * full wire protocol message.\n *\n * By itself, produces an infinite async generator of wire protocol messages and consumers must end\n * the stream by calling `return` on the generator.\n *\n * Note that `for-await` loops call `return` automatically when the loop is exited.\n */\nasync function* readWireProtocolMessages(connection) {\n  const bufferPool = new utils_1.BufferPool();\n  const maxBsonMessageSize = connection.hello?.maxBsonMessageSize ?? kDefaultMaxBsonMessageSize;\n  for await (const [chunk] of (0, stream_1.on)(connection.socket, 'data')) {\n    bufferPool.append(chunk);\n    const sizeOfMessage = bufferPool.getInt32();\n    if (sizeOfMessage == null) {\n      continue;\n    }\n    if (sizeOfMessage < 0) {\n      throw new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}`);\n    }\n    if (sizeOfMessage > maxBsonMessageSize) {\n      throw new error_1.MongoParseError(`Invalid message size: ${sizeOfMessage}, max allowed: ${maxBsonMessageSize}`);\n    }\n    if (sizeOfMessage > bufferPool.length) {\n      continue;\n    }\n    yield bufferPool.read(sizeOfMessage);\n  }\n}\nexports.readWireProtocolMessages = readWireProtocolMessages;\n/**\n * @internal\n *\n * Writes an OP_MSG or OP_QUERY request to the socket, optionally compressing the command. This method\n * waits until the socket's buffer has emptied (the Nodejs socket `drain` event has fired).\n */\nasync function writeCommand(connection, command, options) {\n  const drained = (0, events_1.once)(connection.socket, 'drain');\n  const finalCommand = options.agreedCompressor === 'none' || !commands_1.OpCompressedRequest.canCompress(command) ? command : new commands_1.OpCompressedRequest(command, {\n    agreedCompressor: options.agreedCompressor ?? 'none',\n    zlibCompressionLevel: options.zlibCompressionLevel ?? 0\n  });\n  const buffer = Buffer.concat(await finalCommand.toBin());\n  connection.socket.push(buffer);\n  await drained;\n}\nexports.writeCommand = writeCommand;\n/**\n * @internal\n *\n * Returns an async generator that yields full wire protocol messages from the underlying socket.  This function\n * yields messages until `moreToCome` is false or not present in a response, or the caller cancels the request\n * by calling `return` on the generator.\n *\n * Note that `for-await` loops call `return` automatically when the loop is exited.\n */\nasync function* readMany(connection) {\n  for await (const message of readWireProtocolMessages(connection)) {\n    const response = await (0, compression_1.decompressResponse)(message);\n    yield response;\n    if (!('moreToCome' in response) || !response.moreToCome) {\n      return;\n    }\n  }\n}\nexports.readMany = readMany;\n/**\n * @internal\n *\n * Reads a single wire protocol message out of a connection.\n */\nasync function read(connection) {\n  for await (const value of readMany(connection)) {\n    return value;\n  }\n  throw new error_1.MongoRuntimeError('unable to read message off of connection');\n}\nexports.read = read;","map":{"version":3,"names":["events_1","require","stream_1","timers_1","util_1","constants_1","error_1","mongo_types_1","sessions_1","utils_1","command_monitoring_events_1","commands_1","message_stream_1","stream_description_1","compression_1","shared_1","kStream","Symbol","kQueue","kMessageStream","kGeneration","kLastUseTime","kClusterTime","kDescription","kHello","kAutoEncrypter","kDelayedTimeoutId","INVALID_QUEUE_SIZE","Connection","TypedEventEmitter","constructor","stream","options","commandAsync","promisify","ns","cmd","callback","command","id","address","streamIdentifier","socketTimeoutMS","monitorCommands","serverApi","closed","StreamDescription","generation","now","Map","MessageStream","maxBsonMessageSize","hello","on","message","onMessage","error","onError","onClose","onTimeout","pipe","description","response","receiveResponse","Object","freeze","isMonitoringConnection","value","serviceId","loadBalanced","idleTime","calculateDurationInMs","clusterTime","markAvailable","cleanup","MongoNetworkError","setTimeout","beforeHandshake","MongoNetworkTimeoutError","unref","delayedTimeoutId","clearTimeout","timeout","emit","operationDescription","get","responseTo","size","MongoRuntimeError","entry","entries","next","requestId","orphaned","delete","cb","moreToCome","set","parse","err","documents","document","session","updateSessionFromResponse","$clusterTime","CLUSTER_TIME_RECEIVED","writeConcernError","MongoWriteConcernError","ok","$err","errmsg","code","MongoServerError","undefined","destroy","process","nextTick","once","removeAllListeners","PINNED","UNPINNED","force","completeCleanup","op","values","clear","CLOSE","writableEnded","end","readPreference","getReadPreference","shouldUseOpMsg","supportsOpMsg","version","strict","deprecationErrors","apiVersion","apiStrict","apiDeprecationErrors","hasSessionSupport","greaterThan","applySession","explicit","MongoCompatibilityError","isSharded","mode","$query","$readPreference","toJSON","commandOptions","assign","numberToSkip","numberToReturn","checkKeys","secondaryOk","OpMsgRequest","db","OpQueryRequest","write","COMMAND_STARTED","COMMAND_SUCCEEDED","COMMAND_FAILED","MESSAGE","exports","CryptoConnection","autoEncrypter","MongoMissingDependencyError","serverWireVersion","maxWireVersion","sort","find","findAndModify","indexKeys","createIndexes","indexes","map","index","key","encrypt","toString","then","encrypted","offset","decrypt","res","conn","logicalSessionTimeoutMinutes","__nodejs_mock_server__","proxyHost","hostAddress","remoteAddress","remotePort","HostAddress","fromHostPort","uuidV4","noResponse","documentsReturnedIn","useBigInt64","promoteLongs","promoteValues","promoteBuffers","bsonRegExp","enableUtf8Validation","raw","started","compressor","agreedCompressor","zlibCompressionLevel","CommandStartedEvent","reply","CommandFailedEvent","CommandSucceededEvent","writeCommand","e","ModernConnection","socket","kDefaultMaxBsonMessageSize","readWireProtocolMessages","connection","bufferPool","BufferPool","chunk","append","sizeOfMessage","getInt32","MongoParseError","length","read","drained","finalCommand","OpCompressedRequest","canCompress","buffer","Buffer","concat","toBin","push","readMany","decompressResponse"],"sources":["C:\\Users\\lrmir\\OneDrive\\Desktop\\cs35L\\newFridayz\\Fridayz\\frontend\\node_modules\\mongodb\\src\\cmap\\connection.ts"],"sourcesContent":["import { once } from 'events';\nimport { on } from 'stream';\nimport { clearTimeout, setTimeout } from 'timers';\nimport { promisify } from 'util';\n\nimport type { BSONSerializeOptions, Document, ObjectId } from '../bson';\nimport type { AutoEncrypter } from '../client-side-encryption/auto_encrypter';\nimport {\n  CLOSE,\n  CLUSTER_TIME_RECEIVED,\n  COMMAND_FAILED,\n  COMMAND_STARTED,\n  COMMAND_SUCCEEDED,\n  MESSAGE,\n  PINNED,\n  UNPINNED\n} from '../constants';\nimport {\n  MongoCompatibilityError,\n  MongoMissingDependencyError,\n  MongoNetworkError,\n  MongoNetworkTimeoutError,\n  MongoParseError,\n  MongoRuntimeError,\n  MongoServerError,\n  MongoWriteConcernError\n} from '../error';\nimport type { ServerApi, SupportedNodeConnectionOptions } from '../mongo_client';\nimport { type CancellationToken, TypedEventEmitter } from '../mongo_types';\nimport type { ReadPreferenceLike } from '../read_preference';\nimport { applySession, type ClientSession, updateSessionFromResponse } from '../sessions';\nimport {\n  BufferPool,\n  calculateDurationInMs,\n  type Callback,\n  HostAddress,\n  maxWireVersion,\n  type MongoDBNamespace,\n  now,\n  uuidV4\n} from '../utils';\nimport type { WriteConcern } from '../write_concern';\nimport type { AuthContext } from './auth/auth_provider';\nimport type { MongoCredentials } from './auth/mongo_credentials';\nimport {\n  CommandFailedEvent,\n  CommandStartedEvent,\n  CommandSucceededEvent\n} from './command_monitoring_events';\nimport {\n  OpCompressedRequest,\n  OpMsgRequest,\n  type OpMsgResponse,\n  OpQueryRequest,\n  type OpQueryResponse,\n  type WriteProtocolMessageType\n} from './commands';\nimport type { Stream } from './connect';\nimport type { ClientMetadata } from './handshake/client_metadata';\nimport { MessageStream, type OperationDescription } from './message_stream';\nimport { StreamDescription, type StreamDescriptionOptions } from './stream_description';\nimport { decompressResponse } from './wire_protocol/compression';\nimport { getReadPreference, isSharded } from './wire_protocol/shared';\n\n/** @internal */\nconst kStream = Symbol('stream');\n/** @internal */\nconst kQueue = Symbol('queue');\n/** @internal */\nconst kMessageStream = Symbol('messageStream');\n/** @internal */\nconst kGeneration = Symbol('generation');\n/** @internal */\nconst kLastUseTime = Symbol('lastUseTime');\n/** @internal */\nconst kClusterTime = Symbol('clusterTime');\n/** @internal */\nconst kDescription = Symbol('description');\n/** @internal */\nconst kHello = Symbol('hello');\n/** @internal */\nconst kAutoEncrypter = Symbol('autoEncrypter');\n/** @internal */\nconst kDelayedTimeoutId = Symbol('delayedTimeoutId');\n\nconst INVALID_QUEUE_SIZE = 'Connection internal queue contains more than 1 operation description';\n\n/** @internal */\nexport interface CommandOptions extends BSONSerializeOptions {\n  secondaryOk?: boolean;\n  /** Specify read preference if command supports it */\n  readPreference?: ReadPreferenceLike;\n  monitoring?: boolean;\n  socketTimeoutMS?: number;\n  /** Session to use for the operation */\n  session?: ClientSession;\n  documentsReturnedIn?: string;\n  noResponse?: boolean;\n  omitReadPreference?: boolean;\n\n  // TODO(NODE-2802): Currently the CommandOptions take a property willRetryWrite which is a hint\n  // from executeOperation that the txnNum should be applied to this command.\n  // Applying a session to a command should happen as part of command construction,\n  // most likely in the CommandOperation#executeCommand method, where we have access to\n  // the details we need to determine if a txnNum should also be applied.\n  willRetryWrite?: boolean;\n\n  writeConcern?: WriteConcern;\n}\n\n/** @public */\nexport interface ProxyOptions {\n  proxyHost?: string;\n  proxyPort?: number;\n  proxyUsername?: string;\n  proxyPassword?: string;\n}\n\n/** @public */\nexport interface ConnectionOptions\n  extends SupportedNodeConnectionOptions,\n    StreamDescriptionOptions,\n    ProxyOptions {\n  // Internal creation info\n  id: number | '<monitor>';\n  generation: number;\n  hostAddress: HostAddress;\n  /** @internal */\n  autoEncrypter?: AutoEncrypter;\n  serverApi?: ServerApi;\n  monitorCommands: boolean;\n  /** @internal */\n  connectionType?: typeof Connection;\n  credentials?: MongoCredentials;\n  connectTimeoutMS?: number;\n  tls: boolean;\n  noDelay?: boolean;\n  socketTimeoutMS?: number;\n  cancellationToken?: CancellationToken;\n  metadata: ClientMetadata;\n}\n\n/** @internal */\nexport interface DestroyOptions {\n  /** Force the destruction. */\n  force: boolean;\n}\n\n/** @public */\nexport type ConnectionEvents = {\n  commandStarted(event: CommandStartedEvent): void;\n  commandSucceeded(event: CommandSucceededEvent): void;\n  commandFailed(event: CommandFailedEvent): void;\n  clusterTimeReceived(clusterTime: Document): void;\n  close(): void;\n  message(message: any): void;\n  pinned(pinType: string): void;\n  unpinned(pinType: string): void;\n};\n\n/** @internal */\nexport class Connection extends TypedEventEmitter<ConnectionEvents> {\n  id: number | '<monitor>';\n  address: string;\n  socketTimeoutMS: number;\n  monitorCommands: boolean;\n  /** Indicates that the connection (including underlying TCP socket) has been closed. */\n  closed: boolean;\n  lastHelloMS?: number;\n  serverApi?: ServerApi;\n  helloOk?: boolean;\n  commandAsync: (\n    ns: MongoDBNamespace,\n    cmd: Document,\n    options: CommandOptions | undefined\n  ) => Promise<Document>;\n  /** @internal */\n  authContext?: AuthContext;\n\n  /**@internal */\n  [kDelayedTimeoutId]: NodeJS.Timeout | null;\n  /** @internal */\n  [kDescription]: StreamDescription;\n  /** @internal */\n  [kGeneration]: number;\n  /** @internal */\n  [kLastUseTime]: number;\n  /** @internal */\n  [kQueue]: Map<number, OperationDescription>;\n  /** @internal */\n  [kMessageStream]: MessageStream;\n  /** @internal */\n  [kStream]: Stream;\n  /** @internal */\n  [kHello]: Document | null;\n  /** @internal */\n  [kClusterTime]: Document | null;\n\n  /** @event */\n  static readonly COMMAND_STARTED = COMMAND_STARTED;\n  /** @event */\n  static readonly COMMAND_SUCCEEDED = COMMAND_SUCCEEDED;\n  /** @event */\n  static readonly COMMAND_FAILED = COMMAND_FAILED;\n  /** @event */\n  static readonly CLUSTER_TIME_RECEIVED = CLUSTER_TIME_RECEIVED;\n  /** @event */\n  static readonly CLOSE = CLOSE;\n  /** @event */\n  static readonly MESSAGE = MESSAGE;\n  /** @event */\n  static readonly PINNED = PINNED;\n  /** @event */\n  static readonly UNPINNED = UNPINNED;\n\n  constructor(stream: Stream, options: ConnectionOptions) {\n    super();\n\n    this.commandAsync = promisify(\n      (\n        ns: MongoDBNamespace,\n        cmd: Document,\n        options: CommandOptions | undefined,\n        callback: Callback\n      ) => this.command(ns, cmd, options, callback as any)\n    );\n\n    this.id = options.id;\n    this.address = streamIdentifier(stream, options);\n    this.socketTimeoutMS = options.socketTimeoutMS ?? 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this[kHello] = null;\n    this[kClusterTime] = null;\n\n    this[kDescription] = new StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = now();\n\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new MessageStream({\n      ...options,\n      maxBsonMessageSize: this.hello?.maxBsonMessageSize\n    });\n    this[kStream] = stream;\n\n    this[kDelayedTimeoutId] = null;\n\n    this[kMessageStream].on('message', message => this.onMessage(message));\n    this[kMessageStream].on('error', error => this.onError(error));\n    this[kStream].on('close', () => this.onClose());\n    this[kStream].on('timeout', () => this.onTimeout());\n    this[kStream].on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n\n    // hook the message stream up to the passed in stream\n    this[kStream].pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(this[kStream]);\n  }\n\n  get description(): StreamDescription {\n    return this[kDescription];\n  }\n\n  get hello(): Document | null {\n    return this[kHello];\n  }\n\n  // the `connect` method stores the result of the handshake hello on the connection\n  set hello(response: Document | null) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]);\n\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kHello] = response;\n  }\n\n  // Set the whether the message stream is for a monitoring connection.\n  set isMonitoringConnection(value: boolean) {\n    this[kMessageStream].isMonitoringConnection = value;\n  }\n\n  get isMonitoringConnection(): boolean {\n    return this[kMessageStream].isMonitoringConnection;\n  }\n\n  get serviceId(): ObjectId | undefined {\n    return this.hello?.serviceId;\n  }\n\n  get loadBalanced(): boolean {\n    return this.description.loadBalanced;\n  }\n\n  get generation(): number {\n    return this[kGeneration] || 0;\n  }\n\n  set generation(generation: number) {\n    this[kGeneration] = generation;\n  }\n\n  get idleTime(): number {\n    return calculateDurationInMs(this[kLastUseTime]);\n  }\n\n  get clusterTime(): Document | null {\n    return this[kClusterTime];\n  }\n\n  get stream(): Stream {\n    return this[kStream];\n  }\n\n  markAvailable(): void {\n    this[kLastUseTime] = now();\n  }\n\n  onError(error: Error) {\n    this.cleanup(true, error);\n  }\n\n  onClose() {\n    const message = `connection ${this.id} to ${this.address} closed`;\n    this.cleanup(true, new MongoNetworkError(message));\n  }\n\n  onTimeout() {\n    this[kDelayedTimeoutId] = setTimeout(() => {\n      const message = `connection ${this.id} to ${this.address} timed out`;\n      const beforeHandshake = this.hello == null;\n      this.cleanup(true, new MongoNetworkTimeoutError(message, { beforeHandshake }));\n    }, 1).unref(); // No need for this timer to hold the event loop open\n  }\n\n  onMessage(message: OpMsgResponse | OpQueryResponse) {\n    const delayedTimeoutId = this[kDelayedTimeoutId];\n    if (delayedTimeoutId != null) {\n      clearTimeout(delayedTimeoutId);\n      this[kDelayedTimeoutId] = null;\n    }\n\n    const socketTimeoutMS = this[kStream].timeout ?? 0;\n    this[kStream].setTimeout(0);\n\n    // always emit the message, in case we are streaming\n    this.emit('message', message);\n    let operationDescription = this[kQueue].get(message.responseTo);\n\n    if (!operationDescription && this.isMonitoringConnection) {\n      // This is how we recover when the initial hello's requestId is not\n      // the responseTo when hello responses have been skipped:\n\n      // First check if the map is of invalid size\n      if (this[kQueue].size > 1) {\n        this.cleanup(true, new MongoRuntimeError(INVALID_QUEUE_SIZE));\n      } else {\n        // Get the first orphaned operation description.\n        const entry = this[kQueue].entries().next();\n        if (entry.value != null) {\n          const [requestId, orphaned]: [number, OperationDescription] = entry.value;\n          // If the orphaned operation description exists then set it.\n          operationDescription = orphaned;\n          // Remove the entry with the bad request id from the queue.\n          this[kQueue].delete(requestId);\n        }\n      }\n    }\n\n    if (!operationDescription) {\n      return;\n    }\n\n    const callback = operationDescription.cb;\n\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n    this[kQueue].delete(message.responseTo);\n    if ('moreToCome' in message && message.moreToCome) {\n      // If the operation description check above does find an orphaned\n      // description and sets the operationDescription then this line will put one\n      // back in the queue with the correct requestId and will resolve not being able\n      // to find the next one via the responseTo of the next streaming hello.\n      this[kQueue].set(message.requestId, operationDescription);\n      this[kStream].setTimeout(socketTimeoutMS);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document: Document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        this[kClusterTime] = document.$clusterTime;\n        this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n\n      if (document.writeConcernError) {\n        callback(new MongoWriteConcernError(document.writeConcernError, document), document);\n        return;\n      }\n\n      if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n        callback(new MongoServerError(document));\n        return;\n      }\n    }\n\n    callback(undefined, message.documents[0]);\n  }\n\n  destroy(options: DestroyOptions, callback?: Callback): void {\n    if (this.closed) {\n      process.nextTick(() => callback?.());\n      return;\n    }\n    if (typeof callback === 'function') {\n      this.once('close', () => process.nextTick(() => callback()));\n    }\n\n    // load balanced mode requires that these listeners remain on the connection\n    // after cleanup on timeouts, errors or close so we remove them before calling\n    // cleanup.\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n    const message = `connection ${this.id} to ${this.address} closed`;\n    this.cleanup(options.force, new MongoNetworkError(message));\n  }\n\n  /**\n   * A method that cleans up the connection.  When `force` is true, this method\n   * forcibly destroys the socket.\n   *\n   * If an error is provided, any in-flight operations will be closed with the error.\n   *\n   * This method does nothing if the connection is already closed.\n   */\n  private cleanup(force: boolean, error?: Error): void {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n\n    const completeCleanup = () => {\n      for (const op of this[kQueue].values()) {\n        op.cb(error);\n      }\n\n      this[kQueue].clear();\n\n      this.emit(Connection.CLOSE);\n    };\n\n    this[kStream].removeAllListeners();\n    this[kMessageStream].removeAllListeners();\n\n    this[kMessageStream].destroy();\n\n    if (force) {\n      this[kStream].destroy();\n      completeCleanup();\n      return;\n    }\n\n    if (!this[kStream].writableEnded) {\n      this[kStream].end(() => {\n        this[kStream].destroy();\n        completeCleanup();\n      });\n    } else {\n      completeCleanup();\n    }\n  }\n\n  command(\n    ns: MongoDBNamespace,\n    command: Document,\n    options: CommandOptions | undefined,\n    callback: Callback\n  ): void {\n    let cmd = { ...command };\n\n    const readPreference = getReadPreference(options);\n    const shouldUseOpMsg = supportsOpMsg(this);\n    const session = options?.session;\n\n    let clusterTime = this.clusterTime;\n\n    if (this.serverApi) {\n      const { version, strict, deprecationErrors } = this.serverApi;\n      cmd.apiVersion = version;\n      if (strict != null) cmd.apiStrict = strict;\n      if (deprecationErrors != null) cmd.apiDeprecationErrors = deprecationErrors;\n    }\n\n    if (hasSessionSupport(this) && session) {\n      if (\n        session.clusterTime &&\n        clusterTime &&\n        session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)\n      ) {\n        clusterTime = session.clusterTime;\n      }\n\n      const err = applySession(session, cmd, options);\n      if (err) {\n        return callback(err);\n      }\n    } else if (session?.explicit) {\n      return callback(new MongoCompatibilityError('Current topology does not support sessions'));\n    }\n\n    // if we have a known cluster time, gossip it\n    if (clusterTime) {\n      cmd.$clusterTime = clusterTime;\n    }\n\n    if (isSharded(this) && !shouldUseOpMsg && readPreference && readPreference.mode !== 'primary') {\n      cmd = {\n        $query: cmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n\n    const commandOptions: Document = Object.assign(\n      {\n        numberToSkip: 0,\n        numberToReturn: -1,\n        checkKeys: false,\n        // This value is not overridable\n        secondaryOk: readPreference.secondaryOk()\n      },\n      options\n    );\n\n    const message = shouldUseOpMsg\n      ? new OpMsgRequest(ns.db, cmd, commandOptions)\n      : new OpQueryRequest(ns.db, cmd, commandOptions);\n\n    try {\n      write(this, message, commandOptions, callback);\n    } catch (err) {\n      callback(err);\n    }\n  }\n}\n\n/** @internal */\nexport class CryptoConnection extends Connection {\n  /** @internal */\n  [kAutoEncrypter]?: AutoEncrypter;\n\n  constructor(stream: Stream, options: ConnectionOptions) {\n    super(stream, options);\n    this[kAutoEncrypter] = options.autoEncrypter;\n  }\n\n  /** @internal @override */\n  override command(\n    ns: MongoDBNamespace,\n    cmd: Document,\n    options: CommandOptions,\n    callback: Callback\n  ): void {\n    const autoEncrypter = this[kAutoEncrypter];\n    if (!autoEncrypter) {\n      return callback(new MongoMissingDependencyError('No AutoEncrypter available for encryption'));\n    }\n\n    const serverWireVersion = maxWireVersion(this);\n    if (serverWireVersion === 0) {\n      // This means the initial handshake hasn't happened yet\n      return super.command(ns, cmd, options, callback);\n    }\n\n    if (serverWireVersion < 8) {\n      callback(\n        new MongoCompatibilityError('Auto-encryption requires a minimum MongoDB version of 4.2')\n      );\n      return;\n    }\n\n    // Save sort or indexKeys based on the command being run\n    // the encrypt API serializes our JS objects to BSON to pass to the native code layer\n    // and then deserializes the encrypted result, the protocol level components\n    // of the command (ex. sort) are then converted to JS objects potentially losing\n    // import key order information. These fields are never encrypted so we can save the values\n    // from before the encryption and replace them after encryption has been performed\n    const sort: Map<string, number> | null = cmd.find || cmd.findAndModify ? cmd.sort : null;\n    const indexKeys: Map<string, number>[] | null = cmd.createIndexes\n      ? cmd.indexes.map((index: { key: Map<string, number> }) => index.key)\n      : null;\n\n    autoEncrypter.encrypt(ns.toString(), cmd, options).then(\n      encrypted => {\n        // Replace the saved values\n        if (sort != null && (cmd.find || cmd.findAndModify)) {\n          encrypted.sort = sort;\n        }\n        if (indexKeys != null && cmd.createIndexes) {\n          for (const [offset, index] of indexKeys.entries()) {\n            // @ts-expect-error `encrypted` is a generic \"command\", but we've narrowed for only `createIndexes` commands here\n            encrypted.indexes[offset].key = index;\n          }\n        }\n\n        super.command(ns, encrypted, options, (err, response) => {\n          if (err || response == null) {\n            callback(err, response);\n            return;\n          }\n\n          autoEncrypter.decrypt(response, options).then(\n            res => callback(undefined, res),\n            err => callback(err)\n          );\n        });\n      },\n      err => {\n        if (err) {\n          callback(err, null);\n        }\n      }\n    );\n  }\n}\n\n/** @internal */\nexport function hasSessionSupport(conn: Connection): boolean {\n  const description = conn.description;\n  return description.logicalSessionTimeoutMinutes != null;\n}\n\nfunction supportsOpMsg(conn: Connection) {\n  const description = conn.description;\n  if (description == null) {\n    return false;\n  }\n\n  return maxWireVersion(conn) >= 6 && !description.__nodejs_mock_server__;\n}\n\nfunction streamIdentifier(stream: Stream, options: ConnectionOptions): string {\n  if (options.proxyHost) {\n    // If proxy options are specified, the properties of `stream` itself\n    // will not accurately reflect what endpoint this is connected to.\n    return options.hostAddress.toString();\n  }\n\n  const { remoteAddress, remotePort } = stream;\n  if (typeof remoteAddress === 'string' && typeof remotePort === 'number') {\n    return HostAddress.fromHostPort(remoteAddress, remotePort).toString();\n  }\n\n  return uuidV4().toString('hex');\n}\n\nfunction write(\n  conn: Connection,\n  command: WriteProtocolMessageType,\n  options: CommandOptions,\n  callback: Callback\n) {\n  options = options ?? {};\n  const operationDescription: OperationDescription = {\n    requestId: command.requestId,\n    cb: callback,\n    session: options.session,\n    noResponse: typeof options.noResponse === 'boolean' ? options.noResponse : false,\n    documentsReturnedIn: options.documentsReturnedIn,\n\n    // for BSON parsing\n    useBigInt64: typeof options.useBigInt64 === 'boolean' ? options.useBigInt64 : false,\n    promoteLongs: typeof options.promoteLongs === 'boolean' ? options.promoteLongs : true,\n    promoteValues: typeof options.promoteValues === 'boolean' ? options.promoteValues : true,\n    promoteBuffers: typeof options.promoteBuffers === 'boolean' ? options.promoteBuffers : false,\n    bsonRegExp: typeof options.bsonRegExp === 'boolean' ? options.bsonRegExp : false,\n    enableUtf8Validation:\n      typeof options.enableUtf8Validation === 'boolean' ? options.enableUtf8Validation : true,\n    raw: typeof options.raw === 'boolean' ? options.raw : false,\n    started: 0\n  };\n\n  if (conn[kDescription] && conn[kDescription].compressor) {\n    operationDescription.agreedCompressor = conn[kDescription].compressor;\n\n    if (conn[kDescription].zlibCompressionLevel) {\n      operationDescription.zlibCompressionLevel = conn[kDescription].zlibCompressionLevel;\n    }\n  }\n\n  if (typeof options.socketTimeoutMS === 'number') {\n    conn[kStream].setTimeout(options.socketTimeoutMS);\n  } else if (conn.socketTimeoutMS !== 0) {\n    conn[kStream].setTimeout(conn.socketTimeoutMS);\n  }\n\n  // if command monitoring is enabled we need to modify the callback here\n  if (conn.monitorCommands) {\n    conn.emit(Connection.COMMAND_STARTED, new CommandStartedEvent(conn, command));\n\n    operationDescription.started = now();\n    operationDescription.cb = (err, reply) => {\n      // Command monitoring spec states that if ok is 1, then we must always emit\n      // a command succeeded event, even if there's an error. Write concern errors\n      // will have an ok: 1 in their reply.\n      if (err && reply?.ok !== 1) {\n        conn.emit(\n          Connection.COMMAND_FAILED,\n          new CommandFailedEvent(conn, command, err, operationDescription.started)\n        );\n      } else {\n        if (reply && (reply.ok === 0 || reply.$err)) {\n          conn.emit(\n            Connection.COMMAND_FAILED,\n            new CommandFailedEvent(conn, command, reply, operationDescription.started)\n          );\n        } else {\n          conn.emit(\n            Connection.COMMAND_SUCCEEDED,\n            new CommandSucceededEvent(conn, command, reply, operationDescription.started)\n          );\n        }\n      }\n\n      if (typeof callback === 'function') {\n        // Since we're passing through the reply with the write concern error now, we\n        // need it not to be provided to the original callback in this case so\n        // retryability does not get tricked into thinking the command actually\n        // succeeded.\n        callback(err, err instanceof MongoWriteConcernError ? undefined : reply);\n      }\n    };\n  }\n\n  if (!operationDescription.noResponse) {\n    conn[kQueue].set(operationDescription.requestId, operationDescription);\n  }\n\n  try {\n    conn[kMessageStream].writeCommand(command, operationDescription);\n  } catch (e) {\n    if (!operationDescription.noResponse) {\n      conn[kQueue].delete(operationDescription.requestId);\n      operationDescription.cb(e);\n      return;\n    }\n  }\n\n  if (operationDescription.noResponse) {\n    operationDescription.cb();\n  }\n}\n\n/** in-progress connection layer */\n\n/** @internal */\nexport class ModernConnection extends TypedEventEmitter<ConnectionEvents> {\n  id: number | '<monitor>';\n  address: string;\n  socketTimeoutMS: number;\n  monitorCommands: boolean;\n  /** Indicates that the connection (including underlying TCP socket) has been closed. */\n  closed: boolean;\n  lastHelloMS?: number;\n  serverApi?: ServerApi;\n  helloOk?: boolean;\n  commandAsync: (\n    ns: MongoDBNamespace,\n    cmd: Document,\n    options: CommandOptions | undefined\n  ) => Promise<Document>;\n  /** @internal */\n  authContext?: AuthContext;\n\n  /**@internal */\n  [kDelayedTimeoutId]: NodeJS.Timeout | null;\n  /** @internal */\n  [kDescription]: StreamDescription;\n  /** @internal */\n  [kGeneration]: number;\n  /** @internal */\n  [kLastUseTime]: number;\n  /** @internal */\n  [kQueue]: Map<number, OperationDescription>;\n  /** @internal */\n  [kMessageStream]: MessageStream;\n  /** @internal */\n  socket: Stream;\n  /** @internal */\n  [kHello]: Document | null;\n  /** @internal */\n  [kClusterTime]: Document | null;\n\n  /** @event */\n  static readonly COMMAND_STARTED = COMMAND_STARTED;\n  /** @event */\n  static readonly COMMAND_SUCCEEDED = COMMAND_SUCCEEDED;\n  /** @event */\n  static readonly COMMAND_FAILED = COMMAND_FAILED;\n  /** @event */\n  static readonly CLUSTER_TIME_RECEIVED = CLUSTER_TIME_RECEIVED;\n  /** @event */\n  static readonly CLOSE = CLOSE;\n  /** @event */\n  static readonly MESSAGE = MESSAGE;\n  /** @event */\n  static readonly PINNED = PINNED;\n  /** @event */\n  static readonly UNPINNED = UNPINNED;\n\n  constructor(stream: Stream, options: ConnectionOptions) {\n    super();\n\n    this.commandAsync = promisify(\n      (\n        ns: MongoDBNamespace,\n        cmd: Document,\n        options: CommandOptions | undefined,\n        callback: Callback\n      ) => this.command(ns, cmd, options, callback as any)\n    );\n\n    this.id = options.id;\n    this.address = streamIdentifier(stream, options);\n    this.socketTimeoutMS = options.socketTimeoutMS ?? 0;\n    this.monitorCommands = options.monitorCommands;\n    this.serverApi = options.serverApi;\n    this.closed = false;\n    this[kHello] = null;\n    this[kClusterTime] = null;\n\n    this[kDescription] = new StreamDescription(this.address, options);\n    this[kGeneration] = options.generation;\n    this[kLastUseTime] = now();\n\n    // setup parser stream and message handling\n    this[kQueue] = new Map();\n    this[kMessageStream] = new MessageStream({\n      ...options,\n      maxBsonMessageSize: this.hello?.maxBsonMessageSize\n    });\n    this.socket = stream;\n\n    this[kDelayedTimeoutId] = null;\n\n    this[kMessageStream].on('message', message => this.onMessage(message));\n    this[kMessageStream].on('error', error => this.onError(error));\n    this.socket.on('close', () => this.onClose());\n    this.socket.on('timeout', () => this.onTimeout());\n    this.socket.on('error', () => {\n      /* ignore errors, listen to `close` instead */\n    });\n\n    // hook the message stream up to the passed in stream\n    this.socket.pipe(this[kMessageStream]);\n    this[kMessageStream].pipe(this.socket);\n  }\n\n  get description(): StreamDescription {\n    return this[kDescription];\n  }\n\n  get hello(): Document | null {\n    return this[kHello];\n  }\n\n  // the `connect` method stores the result of the handshake hello on the connection\n  set hello(response: Document | null) {\n    this[kDescription].receiveResponse(response);\n    this[kDescription] = Object.freeze(this[kDescription]);\n\n    // TODO: remove this, and only use the `StreamDescription` in the future\n    this[kHello] = response;\n  }\n\n  // Set the whether the message stream is for a monitoring connection.\n  set isMonitoringConnection(value: boolean) {\n    this[kMessageStream].isMonitoringConnection = value;\n  }\n\n  get isMonitoringConnection(): boolean {\n    return this[kMessageStream].isMonitoringConnection;\n  }\n\n  get serviceId(): ObjectId | undefined {\n    return this.hello?.serviceId;\n  }\n\n  get loadBalanced(): boolean {\n    return this.description.loadBalanced;\n  }\n\n  get generation(): number {\n    return this[kGeneration] || 0;\n  }\n\n  set generation(generation: number) {\n    this[kGeneration] = generation;\n  }\n\n  get idleTime(): number {\n    return calculateDurationInMs(this[kLastUseTime]);\n  }\n\n  get clusterTime(): Document | null {\n    return this[kClusterTime];\n  }\n\n  get stream(): Stream {\n    return this.socket;\n  }\n\n  get hasSessionSupport(): boolean {\n    return this.description.logicalSessionTimeoutMinutes != null;\n  }\n\n  get supportsOpMsg(): boolean {\n    return (\n      this.description != null &&\n      maxWireVersion(this as any as Connection) >= 6 &&\n      !this.description.__nodejs_mock_server__\n    );\n  }\n\n  markAvailable(): void {\n    this[kLastUseTime] = now();\n  }\n\n  onError(error: Error) {\n    this.cleanup(true, error);\n  }\n\n  onClose() {\n    const message = `connection ${this.id} to ${this.address} closed`;\n    this.cleanup(true, new MongoNetworkError(message));\n  }\n\n  onTimeout() {\n    this[kDelayedTimeoutId] = setTimeout(() => {\n      const message = `connection ${this.id} to ${this.address} timed out`;\n      const beforeHandshake = this.hello == null;\n      this.cleanup(true, new MongoNetworkTimeoutError(message, { beforeHandshake }));\n    }, 1).unref(); // No need for this timer to hold the event loop open\n  }\n\n  onMessage(message: OpMsgResponse | OpQueryResponse) {\n    const delayedTimeoutId = this[kDelayedTimeoutId];\n    if (delayedTimeoutId != null) {\n      clearTimeout(delayedTimeoutId);\n      this[kDelayedTimeoutId] = null;\n    }\n\n    const socketTimeoutMS = this.socket.timeout ?? 0;\n    this.socket.setTimeout(0);\n\n    // always emit the message, in case we are streaming\n    this.emit('message', message);\n    let operationDescription = this[kQueue].get(message.responseTo);\n\n    if (!operationDescription && this.isMonitoringConnection) {\n      // This is how we recover when the initial hello's requestId is not\n      // the responseTo when hello responses have been skipped:\n\n      // First check if the map is of invalid size\n      if (this[kQueue].size > 1) {\n        this.cleanup(true, new MongoRuntimeError(INVALID_QUEUE_SIZE));\n      } else {\n        // Get the first orphaned operation description.\n        const entry = this[kQueue].entries().next();\n        if (entry.value != null) {\n          const [requestId, orphaned]: [number, OperationDescription] = entry.value;\n          // If the orphaned operation description exists then set it.\n          operationDescription = orphaned;\n          // Remove the entry with the bad request id from the queue.\n          this[kQueue].delete(requestId);\n        }\n      }\n    }\n\n    if (!operationDescription) {\n      return;\n    }\n\n    const callback = operationDescription.cb;\n\n    // SERVER-45775: For exhaust responses we should be able to use the same requestId to\n    // track response, however the server currently synthetically produces remote requests\n    // making the `responseTo` change on each response\n    this[kQueue].delete(message.responseTo);\n    if ('moreToCome' in message && message.moreToCome) {\n      // If the operation description check above does find an orphaned\n      // description and sets the operationDescription then this line will put one\n      // back in the queue with the correct requestId and will resolve not being able\n      // to find the next one via the responseTo of the next streaming hello.\n      this[kQueue].set(message.requestId, operationDescription);\n      this.socket.setTimeout(socketTimeoutMS);\n    }\n\n    try {\n      // Pass in the entire description because it has BSON parsing options\n      message.parse(operationDescription);\n    } catch (err) {\n      // If this error is generated by our own code, it will already have the correct class applied\n      // if it is not, then it is coming from a catastrophic data parse failure or the BSON library\n      // in either case, it should not be wrapped\n      callback(err);\n      return;\n    }\n\n    if (message.documents[0]) {\n      const document: Document = message.documents[0];\n      const session = operationDescription.session;\n      if (session) {\n        updateSessionFromResponse(session, document);\n      }\n\n      if (document.$clusterTime) {\n        this[kClusterTime] = document.$clusterTime;\n        this.emit(Connection.CLUSTER_TIME_RECEIVED, document.$clusterTime);\n      }\n\n      if (document.writeConcernError) {\n        callback(new MongoWriteConcernError(document.writeConcernError, document), document);\n        return;\n      }\n\n      if (document.ok === 0 || document.$err || document.errmsg || document.code) {\n        callback(new MongoServerError(document));\n        return;\n      }\n    }\n\n    callback(undefined, message.documents[0]);\n  }\n\n  destroy(options: DestroyOptions, callback?: Callback): void {\n    if (this.closed) {\n      process.nextTick(() => callback?.());\n      return;\n    }\n    if (typeof callback === 'function') {\n      this.once('close', () => process.nextTick(() => callback()));\n    }\n\n    // load balanced mode requires that these listeners remain on the connection\n    // after cleanup on timeouts, errors or close so we remove them before calling\n    // cleanup.\n    this.removeAllListeners(Connection.PINNED);\n    this.removeAllListeners(Connection.UNPINNED);\n    const message = `connection ${this.id} to ${this.address} closed`;\n    this.cleanup(options.force, new MongoNetworkError(message));\n  }\n\n  /**\n   * A method that cleans up the connection.  When `force` is true, this method\n   * forcibly destroys the socket.\n   *\n   * If an error is provided, any in-flight operations will be closed with the error.\n   *\n   * This method does nothing if the connection is already closed.\n   */\n  private cleanup(force: boolean, error?: Error): void {\n    if (this.closed) {\n      return;\n    }\n\n    this.closed = true;\n\n    const completeCleanup = () => {\n      for (const op of this[kQueue].values()) {\n        op.cb(error);\n      }\n\n      this[kQueue].clear();\n\n      this.emit(Connection.CLOSE);\n    };\n\n    this.socket.removeAllListeners();\n    this[kMessageStream].removeAllListeners();\n\n    this[kMessageStream].destroy();\n\n    if (force) {\n      this.socket.destroy();\n      completeCleanup();\n      return;\n    }\n\n    if (!this.socket.writableEnded) {\n      this.socket.end(() => {\n        this.socket.destroy();\n        completeCleanup();\n      });\n    } else {\n      completeCleanup();\n    }\n  }\n\n  command(\n    ns: MongoDBNamespace,\n    command: Document,\n    options: CommandOptions | undefined,\n    callback: Callback\n  ): void {\n    let cmd = { ...command };\n\n    const readPreference = getReadPreference(options);\n    const session = options?.session;\n\n    let clusterTime = this.clusterTime;\n\n    if (this.serverApi) {\n      const { version, strict, deprecationErrors } = this.serverApi;\n      cmd.apiVersion = version;\n      if (strict != null) cmd.apiStrict = strict;\n      if (deprecationErrors != null) cmd.apiDeprecationErrors = deprecationErrors;\n    }\n\n    if (this.hasSessionSupport && session) {\n      if (\n        session.clusterTime &&\n        clusterTime &&\n        session.clusterTime.clusterTime.greaterThan(clusterTime.clusterTime)\n      ) {\n        clusterTime = session.clusterTime;\n      }\n\n      const err = applySession(session, cmd, options);\n      if (err) {\n        return callback(err);\n      }\n    } else if (session?.explicit) {\n      return callback(new MongoCompatibilityError('Current topology does not support sessions'));\n    }\n\n    // if we have a known cluster time, gossip it\n    if (clusterTime) {\n      cmd.$clusterTime = clusterTime;\n    }\n\n    if (\n      // @ts-expect-error ModernConnections cannot be passed as connections\n      isSharded(this) &&\n      !this.supportsOpMsg &&\n      readPreference &&\n      readPreference.mode !== 'primary'\n    ) {\n      cmd = {\n        $query: cmd,\n        $readPreference: readPreference.toJSON()\n      };\n    }\n\n    const commandOptions: Document = Object.assign(\n      {\n        numberToSkip: 0,\n        numberToReturn: -1,\n        checkKeys: false,\n        // This value is not overridable\n        secondaryOk: readPreference.secondaryOk()\n      },\n      options\n    );\n\n    const message = this.supportsOpMsg\n      ? new OpMsgRequest(ns.db, cmd, commandOptions)\n      : new OpQueryRequest(ns.db, cmd, commandOptions);\n\n    try {\n      write(this as any as Connection, message, commandOptions, callback);\n    } catch (err) {\n      callback(err);\n    }\n  }\n}\n\nconst kDefaultMaxBsonMessageSize = 1024 * 1024 * 16 * 4;\n\n/**\n * @internal\n *\n * This helper reads chucks of data out of a socket and buffers them until it has received a\n * full wire protocol message.\n *\n * By itself, produces an infinite async generator of wire protocol messages and consumers must end\n * the stream by calling `return` on the generator.\n *\n * Note that `for-await` loops call `return` automatically when the loop is exited.\n */\nexport async function* readWireProtocolMessages(\n  connection: ModernConnection\n): AsyncGenerator<Buffer> {\n  const bufferPool = new BufferPool();\n  const maxBsonMessageSize = connection.hello?.maxBsonMessageSize ?? kDefaultMaxBsonMessageSize;\n  for await (const [chunk] of on(connection.socket, 'data')) {\n    bufferPool.append(chunk);\n    const sizeOfMessage = bufferPool.getInt32();\n\n    if (sizeOfMessage == null) {\n      continue;\n    }\n\n    if (sizeOfMessage < 0) {\n      throw new MongoParseError(`Invalid message size: ${sizeOfMessage}`);\n    }\n\n    if (sizeOfMessage > maxBsonMessageSize) {\n      throw new MongoParseError(\n        `Invalid message size: ${sizeOfMessage}, max allowed: ${maxBsonMessageSize}`\n      );\n    }\n\n    if (sizeOfMessage > bufferPool.length) {\n      continue;\n    }\n\n    yield bufferPool.read(sizeOfMessage);\n  }\n}\n\n/**\n * @internal\n *\n * Writes an OP_MSG or OP_QUERY request to the socket, optionally compressing the command. This method\n * waits until the socket's buffer has emptied (the Nodejs socket `drain` event has fired).\n */\nexport async function writeCommand(\n  connection: ModernConnection,\n  command: WriteProtocolMessageType,\n  options: Partial<Pick<OperationDescription, 'agreedCompressor' | 'zlibCompressionLevel'>>\n): Promise<void> {\n  const drained = once(connection.socket, 'drain');\n  const finalCommand =\n    options.agreedCompressor === 'none' || !OpCompressedRequest.canCompress(command)\n      ? command\n      : new OpCompressedRequest(command, {\n          agreedCompressor: options.agreedCompressor ?? 'none',\n          zlibCompressionLevel: options.zlibCompressionLevel ?? 0\n        });\n  const buffer = Buffer.concat(await finalCommand.toBin());\n  connection.socket.push(buffer);\n  await drained;\n}\n\n/**\n * @internal\n *\n * Returns an async generator that yields full wire protocol messages from the underlying socket.  This function\n * yields messages until `moreToCome` is false or not present in a response, or the caller cancels the request\n * by calling `return` on the generator.\n *\n * Note that `for-await` loops call `return` automatically when the loop is exited.\n */\nexport async function* readMany(\n  connection: ModernConnection\n): AsyncGenerator<OpMsgResponse | OpQueryResponse> {\n  for await (const message of readWireProtocolMessages(connection)) {\n    const response = await decompressResponse(message);\n    yield response;\n\n    if (!('moreToCome' in response) || !response.moreToCome) {\n      return;\n    }\n  }\n}\n\n/**\n * @internal\n *\n * Reads a single wire protocol message out of a connection.\n */\nexport async function read(connection: ModernConnection): Promise<OpMsgResponse | OpQueryResponse> {\n  for await (const value of readMany(connection)) {\n    return value;\n  }\n\n  throw new MongoRuntimeError('unable to read message off of connection');\n}\n"],"mappings":";;;;;;AAAA,MAAAA,QAAA,GAAAC,OAAA;AACA,MAAAC,QAAA,GAAAD,OAAA;AACA,MAAAE,QAAA,GAAAF,OAAA;AACA,MAAAG,MAAA,GAAAH,OAAA;AAIA,MAAAI,WAAA,GAAAJ,OAAA;AAUA,MAAAK,OAAA,GAAAL,OAAA;AAWA,MAAAM,aAAA,GAAAN,OAAA;AAEA,MAAAO,UAAA,GAAAP,OAAA;AACA,MAAAQ,OAAA,GAAAR,OAAA;AAaA,MAAAS,2BAAA,GAAAT,OAAA;AAKA,MAAAU,UAAA,GAAAV,OAAA;AAUA,MAAAW,gBAAA,GAAAX,OAAA;AACA,MAAAY,oBAAA,GAAAZ,OAAA;AACA,MAAAa,aAAA,GAAAb,OAAA;AACA,MAAAc,QAAA,GAAAd,OAAA;AAEA;AACA,MAAMe,OAAO,GAAGC,MAAM,CAAC,QAAQ,CAAC;AAChC;AACA,MAAMC,MAAM,GAAGD,MAAM,CAAC,OAAO,CAAC;AAC9B;AACA,MAAME,cAAc,GAAGF,MAAM,CAAC,eAAe,CAAC;AAC9C;AACA,MAAMG,WAAW,GAAGH,MAAM,CAAC,YAAY,CAAC;AACxC;AACA,MAAMI,YAAY,GAAGJ,MAAM,CAAC,aAAa,CAAC;AAC1C;AACA,MAAMK,YAAY,GAAGL,MAAM,CAAC,aAAa,CAAC;AAC1C;AACA,MAAMM,YAAY,GAAGN,MAAM,CAAC,aAAa,CAAC;AAC1C;AACA,MAAMO,MAAM,GAAGP,MAAM,CAAC,OAAO,CAAC;AAC9B;AACA,MAAMQ,cAAc,GAAGR,MAAM,CAAC,eAAe,CAAC;AAC9C;AACA,MAAMS,iBAAiB,GAAGT,MAAM,CAAC,kBAAkB,CAAC;AAEpD,MAAMU,kBAAkB,GAAG,sEAAsE;AA2EjG;AACA,MAAaC,UAAW,SAAQrB,aAAA,CAAAsB,iBAAmC;EAsDjEC,YAAYC,MAAc,EAAEC,OAA0B;IACpD,KAAK,EAAE;IAEP,IAAI,CAACC,YAAY,GAAG,IAAA7B,MAAA,CAAA8B,SAAS,EAC3B,CACEC,EAAoB,EACpBC,GAAa,EACbJ,OAAmC,EACnCK,QAAkB,KACf,IAAI,CAACC,OAAO,CAACH,EAAE,EAAEC,GAAG,EAAEJ,OAAO,EAAEK,QAAe,CAAC,CACrD;IAED,IAAI,CAACE,EAAE,GAAGP,OAAO,CAACO,EAAE;IACpB,IAAI,CAACC,OAAO,GAAGC,gBAAgB,CAACV,MAAM,EAAEC,OAAO,CAAC;IAChD,IAAI,CAACU,eAAe,GAAGV,OAAO,CAACU,eAAe,IAAI,CAAC;IACnD,IAAI,CAACC,eAAe,GAAGX,OAAO,CAACW,eAAe;IAC9C,IAAI,CAACC,SAAS,GAAGZ,OAAO,CAACY,SAAS;IAClC,IAAI,CAACC,MAAM,GAAG,KAAK;IACnB,IAAI,CAACrB,MAAM,CAAC,GAAG,IAAI;IACnB,IAAI,CAACF,YAAY,CAAC,GAAG,IAAI;IAEzB,IAAI,CAACC,YAAY,CAAC,GAAG,IAAIV,oBAAA,CAAAiC,iBAAiB,CAAC,IAAI,CAACN,OAAO,EAAER,OAAO,CAAC;IACjE,IAAI,CAACZ,WAAW,CAAC,GAAGY,OAAO,CAACe,UAAU;IACtC,IAAI,CAAC1B,YAAY,CAAC,GAAG,IAAAZ,OAAA,CAAAuC,GAAG,GAAE;IAE1B;IACA,IAAI,CAAC9B,MAAM,CAAC,GAAG,IAAI+B,GAAG,EAAE;IACxB,IAAI,CAAC9B,cAAc,CAAC,GAAG,IAAIP,gBAAA,CAAAsC,aAAa,CAAC;MACvC,GAAGlB,OAAO;MACVmB,kBAAkB,EAAE,IAAI,CAACC,KAAK,EAAED;KACjC,CAAC;IACF,IAAI,CAACnC,OAAO,CAAC,GAAGe,MAAM;IAEtB,IAAI,CAACL,iBAAiB,CAAC,GAAG,IAAI;IAE9B,IAAI,CAACP,cAAc,CAAC,CAACkC,EAAE,CAAC,SAAS,EAAEC,OAAO,IAAI,IAAI,CAACC,SAAS,CAACD,OAAO,CAAC,CAAC;IACtE,IAAI,CAACnC,cAAc,CAAC,CAACkC,EAAE,CAAC,OAAO,EAAEG,KAAK,IAAI,IAAI,CAACC,OAAO,CAACD,KAAK,CAAC,CAAC;IAC9D,IAAI,CAACxC,OAAO,CAAC,CAACqC,EAAE,CAAC,OAAO,EAAE,MAAM,IAAI,CAACK,OAAO,EAAE,CAAC;IAC/C,IAAI,CAAC1C,OAAO,CAAC,CAACqC,EAAE,CAAC,SAAS,EAAE,MAAM,IAAI,CAACM,SAAS,EAAE,CAAC;IACnD,IAAI,CAAC3C,OAAO,CAAC,CAACqC,EAAE,CAAC,OAAO,EAAE,MAAK;MAC7B;IAAA,CACD,CAAC;IAEF;IACA,IAAI,CAACrC,OAAO,CAAC,CAAC4C,IAAI,CAAC,IAAI,CAACzC,cAAc,CAAC,CAAC;IACxC,IAAI,CAACA,cAAc,CAAC,CAACyC,IAAI,CAAC,IAAI,CAAC5C,OAAO,CAAC,CAAC;EAC1C;EAEA,IAAI6C,WAAWA,CAAA;IACb,OAAO,IAAI,CAACtC,YAAY,CAAC;EAC3B;EAEA,IAAI6B,KAAKA,CAAA;IACP,OAAO,IAAI,CAAC5B,MAAM,CAAC;EACrB;EAEA;EACA,IAAI4B,KAAKA,CAACU,QAAyB;IACjC,IAAI,CAACvC,YAAY,CAAC,CAACwC,eAAe,CAACD,QAAQ,CAAC;IAC5C,IAAI,CAACvC,YAAY,CAAC,GAAGyC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC1C,YAAY,CAAC,CAAC;IAEtD;IACA,IAAI,CAACC,MAAM,CAAC,GAAGsC,QAAQ;EACzB;EAEA;EACA,IAAII,sBAAsBA,CAACC,KAAc;IACvC,IAAI,CAAChD,cAAc,CAAC,CAAC+C,sBAAsB,GAAGC,KAAK;EACrD;EAEA,IAAID,sBAAsBA,CAAA;IACxB,OAAO,IAAI,CAAC/C,cAAc,CAAC,CAAC+C,sBAAsB;EACpD;EAEA,IAAIE,SAASA,CAAA;IACX,OAAO,IAAI,CAAChB,KAAK,EAAEgB,SAAS;EAC9B;EAEA,IAAIC,YAAYA,CAAA;IACd,OAAO,IAAI,CAACR,WAAW,CAACQ,YAAY;EACtC;EAEA,IAAItB,UAAUA,CAAA;IACZ,OAAO,IAAI,CAAC3B,WAAW,CAAC,IAAI,CAAC;EAC/B;EAEA,IAAI2B,UAAUA,CAACA,UAAkB;IAC/B,IAAI,CAAC3B,WAAW,CAAC,GAAG2B,UAAU;EAChC;EAEA,IAAIuB,QAAQA,CAAA;IACV,OAAO,IAAA7D,OAAA,CAAA8D,qBAAqB,EAAC,IAAI,CAAClD,YAAY,CAAC,CAAC;EAClD;EAEA,IAAImD,WAAWA,CAAA;IACb,OAAO,IAAI,CAAClD,YAAY,CAAC;EAC3B;EAEA,IAAIS,MAAMA,CAAA;IACR,OAAO,IAAI,CAACf,OAAO,CAAC;EACtB;EAEAyD,aAAaA,CAAA;IACX,IAAI,CAACpD,YAAY,CAAC,GAAG,IAAAZ,OAAA,CAAAuC,GAAG,GAAE;EAC5B;EAEAS,OAAOA,CAACD,KAAY;IAClB,IAAI,CAACkB,OAAO,CAAC,IAAI,EAAElB,KAAK,CAAC;EAC3B;EAEAE,OAAOA,CAAA;IACL,MAAMJ,OAAO,GAAG,cAAc,IAAI,CAACf,EAAE,OAAO,IAAI,CAACC,OAAO,SAAS;IACjE,IAAI,CAACkC,OAAO,CAAC,IAAI,EAAE,IAAIpE,OAAA,CAAAqE,iBAAiB,CAACrB,OAAO,CAAC,CAAC;EACpD;EAEAK,SAASA,CAAA;IACP,IAAI,CAACjC,iBAAiB,CAAC,GAAG,IAAAvB,QAAA,CAAAyE,UAAU,EAAC,MAAK;MACxC,MAAMtB,OAAO,GAAG,cAAc,IAAI,CAACf,EAAE,OAAO,IAAI,CAACC,OAAO,YAAY;MACpE,MAAMqC,eAAe,GAAG,IAAI,CAACzB,KAAK,IAAI,IAAI;MAC1C,IAAI,CAACsB,OAAO,CAAC,IAAI,EAAE,IAAIpE,OAAA,CAAAwE,wBAAwB,CAACxB,OAAO,EAAE;QAAEuB;MAAe,CAAE,CAAC,CAAC;IAChF,CAAC,EAAE,CAAC,CAAC,CAACE,KAAK,EAAE,CAAC,CAAC;EACjB;EAEAxB,SAASA,CAACD,OAAwC;IAChD,MAAM0B,gBAAgB,GAAG,IAAI,CAACtD,iBAAiB,CAAC;IAChD,IAAIsD,gBAAgB,IAAI,IAAI,EAAE;MAC5B,IAAA7E,QAAA,CAAA8E,YAAY,EAACD,gBAAgB,CAAC;MAC9B,IAAI,CAACtD,iBAAiB,CAAC,GAAG,IAAI;;IAGhC,MAAMgB,eAAe,GAAG,IAAI,CAAC1B,OAAO,CAAC,CAACkE,OAAO,IAAI,CAAC;IAClD,IAAI,CAAClE,OAAO,CAAC,CAAC4D,UAAU,CAAC,CAAC,CAAC;IAE3B;IACA,IAAI,CAACO,IAAI,CAAC,SAAS,EAAE7B,OAAO,CAAC;IAC7B,IAAI8B,oBAAoB,GAAG,IAAI,CAAClE,MAAM,CAAC,CAACmE,GAAG,CAAC/B,OAAO,CAACgC,UAAU,CAAC;IAE/D,IAAI,CAACF,oBAAoB,IAAI,IAAI,CAAClB,sBAAsB,EAAE;MACxD;MACA;MAEA;MACA,IAAI,IAAI,CAAChD,MAAM,CAAC,CAACqE,IAAI,GAAG,CAAC,EAAE;QACzB,IAAI,CAACb,OAAO,CAAC,IAAI,EAAE,IAAIpE,OAAA,CAAAkF,iBAAiB,CAAC7D,kBAAkB,CAAC,CAAC;OAC9D,MAAM;QACL;QACA,MAAM8D,KAAK,GAAG,IAAI,CAACvE,MAAM,CAAC,CAACwE,OAAO,EAAE,CAACC,IAAI,EAAE;QAC3C,IAAIF,KAAK,CAACtB,KAAK,IAAI,IAAI,EAAE;UACvB,MAAM,CAACyB,SAAS,EAAEC,QAAQ,CAAC,GAAmCJ,KAAK,CAACtB,KAAK;UACzE;UACAiB,oBAAoB,GAAGS,QAAQ;UAC/B;UACA,IAAI,CAAC3E,MAAM,CAAC,CAAC4E,MAAM,CAACF,SAAS,CAAC;;;;IAKpC,IAAI,CAACR,oBAAoB,EAAE;MACzB;;IAGF,MAAM/C,QAAQ,GAAG+C,oBAAoB,CAACW,EAAE;IAExC;IACA;IACA;IACA,IAAI,CAAC7E,MAAM,CAAC,CAAC4E,MAAM,CAACxC,OAAO,CAACgC,UAAU,CAAC;IACvC,IAAI,YAAY,IAAIhC,OAAO,IAAIA,OAAO,CAAC0C,UAAU,EAAE;MACjD;MACA;MACA;MACA;MACA,IAAI,CAAC9E,MAAM,CAAC,CAAC+E,GAAG,CAAC3C,OAAO,CAACsC,SAAS,EAAER,oBAAoB,CAAC;MACzD,IAAI,CAACpE,OAAO,CAAC,CAAC4D,UAAU,CAAClC,eAAe,CAAC;;IAG3C,IAAI;MACF;MACAY,OAAO,CAAC4C,KAAK,CAACd,oBAAoB,CAAC;KACpC,CAAC,OAAOe,GAAG,EAAE;MACZ;MACA;MACA;MACA9D,QAAQ,CAAC8D,GAAG,CAAC;MACb;;IAGF,IAAI7C,OAAO,CAAC8C,SAAS,CAAC,CAAC,CAAC,EAAE;MACxB,MAAMC,QAAQ,GAAa/C,OAAO,CAAC8C,SAAS,CAAC,CAAC,CAAC;MAC/C,MAAME,OAAO,GAAGlB,oBAAoB,CAACkB,OAAO;MAC5C,IAAIA,OAAO,EAAE;QACX,IAAA9F,UAAA,CAAA+F,yBAAyB,EAACD,OAAO,EAAED,QAAQ,CAAC;;MAG9C,IAAIA,QAAQ,CAACG,YAAY,EAAE;QACzB,IAAI,CAAClF,YAAY,CAAC,GAAG+E,QAAQ,CAACG,YAAY;QAC1C,IAAI,CAACrB,IAAI,CAACvD,UAAU,CAAC6E,qBAAqB,EAAEJ,QAAQ,CAACG,YAAY,CAAC;;MAGpE,IAAIH,QAAQ,CAACK,iBAAiB,EAAE;QAC9BrE,QAAQ,CAAC,IAAI/B,OAAA,CAAAqG,sBAAsB,CAACN,QAAQ,CAACK,iBAAiB,EAAEL,QAAQ,CAAC,EAAEA,QAAQ,CAAC;QACpF;;MAGF,IAAIA,QAAQ,CAACO,EAAE,KAAK,CAAC,IAAIP,QAAQ,CAACQ,IAAI,IAAIR,QAAQ,CAACS,MAAM,IAAIT,QAAQ,CAACU,IAAI,EAAE;QAC1E1E,QAAQ,CAAC,IAAI/B,OAAA,CAAA0G,gBAAgB,CAACX,QAAQ,CAAC,CAAC;QACxC;;;IAIJhE,QAAQ,CAAC4E,SAAS,EAAE3D,OAAO,CAAC8C,SAAS,CAAC,CAAC,CAAC,CAAC;EAC3C;EAEAc,OAAOA,CAAClF,OAAuB,EAAEK,QAAmB;IAClD,IAAI,IAAI,CAACQ,MAAM,EAAE;MACfsE,OAAO,CAACC,QAAQ,CAAC,MAAM/E,QAAQ,GAAE,CAAE,CAAC;MACpC;;IAEF,IAAI,OAAOA,QAAQ,KAAK,UAAU,EAAE;MAClC,IAAI,CAACgF,IAAI,CAAC,OAAO,EAAE,MAAMF,OAAO,CAACC,QAAQ,CAAC,MAAM/E,QAAQ,EAAE,CAAC,CAAC;;IAG9D;IACA;IACA;IACA,IAAI,CAACiF,kBAAkB,CAAC1F,UAAU,CAAC2F,MAAM,CAAC;IAC1C,IAAI,CAACD,kBAAkB,CAAC1F,UAAU,CAAC4F,QAAQ,CAAC;IAC5C,MAAMlE,OAAO,GAAG,cAAc,IAAI,CAACf,EAAE,OAAO,IAAI,CAACC,OAAO,SAAS;IACjE,IAAI,CAACkC,OAAO,CAAC1C,OAAO,CAACyF,KAAK,EAAE,IAAInH,OAAA,CAAAqE,iBAAiB,CAACrB,OAAO,CAAC,CAAC;EAC7D;EAEA;;;;;;;;EAQQoB,OAAOA,CAAC+C,KAAc,EAAEjE,KAAa;IAC3C,IAAI,IAAI,CAACX,MAAM,EAAE;MACf;;IAGF,IAAI,CAACA,MAAM,GAAG,IAAI;IAElB,MAAM6E,eAAe,GAAGA,CAAA,KAAK;MAC3B,KAAK,MAAMC,EAAE,IAAI,IAAI,CAACzG,MAAM,CAAC,CAAC0G,MAAM,EAAE,EAAE;QACtCD,EAAE,CAAC5B,EAAE,CAACvC,KAAK,CAAC;;MAGd,IAAI,CAACtC,MAAM,CAAC,CAAC2G,KAAK,EAAE;MAEpB,IAAI,CAAC1C,IAAI,CAACvD,UAAU,CAACkG,KAAK,CAAC;IAC7B,CAAC;IAED,IAAI,CAAC9G,OAAO,CAAC,CAACsG,kBAAkB,EAAE;IAClC,IAAI,CAACnG,cAAc,CAAC,CAACmG,kBAAkB,EAAE;IAEzC,IAAI,CAACnG,cAAc,CAAC,CAAC+F,OAAO,EAAE;IAE9B,IAAIO,KAAK,EAAE;MACT,IAAI,CAACzG,OAAO,CAAC,CAACkG,OAAO,EAAE;MACvBQ,eAAe,EAAE;MACjB;;IAGF,IAAI,CAAC,IAAI,CAAC1G,OAAO,CAAC,CAAC+G,aAAa,EAAE;MAChC,IAAI,CAAC/G,OAAO,CAAC,CAACgH,GAAG,CAAC,MAAK;QACrB,IAAI,CAAChH,OAAO,CAAC,CAACkG,OAAO,EAAE;QACvBQ,eAAe,EAAE;MACnB,CAAC,CAAC;KACH,MAAM;MACLA,eAAe,EAAE;;EAErB;EAEApF,OAAOA,CACLH,EAAoB,EACpBG,OAAiB,EACjBN,OAAmC,EACnCK,QAAkB;IAElB,IAAID,GAAG,GAAG;MAAE,GAAGE;IAAO,CAAE;IAExB,MAAM2F,cAAc,GAAG,IAAAlH,QAAA,CAAAmH,iBAAiB,EAAClG,OAAO,CAAC;IACjD,MAAMmG,cAAc,GAAGC,aAAa,CAAC,IAAI,CAAC;IAC1C,MAAM9B,OAAO,GAAGtE,OAAO,EAAEsE,OAAO;IAEhC,IAAI9B,WAAW,GAAG,IAAI,CAACA,WAAW;IAElC,IAAI,IAAI,CAAC5B,SAAS,EAAE;MAClB,MAAM;QAAEyF,OAAO;QAAEC,MAAM;QAAEC;MAAiB,CAAE,GAAG,IAAI,CAAC3F,SAAS;MAC7DR,GAAG,CAACoG,UAAU,GAAGH,OAAO;MACxB,IAAIC,MAAM,IAAI,IAAI,EAAElG,GAAG,CAACqG,SAAS,GAAGH,MAAM;MAC1C,IAAIC,iBAAiB,IAAI,IAAI,EAAEnG,GAAG,CAACsG,oBAAoB,GAAGH,iBAAiB;;IAG7E,IAAII,iBAAiB,CAAC,IAAI,CAAC,IAAIrC,OAAO,EAAE;MACtC,IACEA,OAAO,CAAC9B,WAAW,IACnBA,WAAW,IACX8B,OAAO,CAAC9B,WAAW,CAACA,WAAW,CAACoE,WAAW,CAACpE,WAAW,CAACA,WAAW,CAAC,EACpE;QACAA,WAAW,GAAG8B,OAAO,CAAC9B,WAAW;;MAGnC,MAAM2B,GAAG,GAAG,IAAA3F,UAAA,CAAAqI,YAAY,EAACvC,OAAO,EAAElE,GAAG,EAAEJ,OAAO,CAAC;MAC/C,IAAImE,GAAG,EAAE;QACP,OAAO9D,QAAQ,CAAC8D,GAAG,CAAC;;KAEvB,MAAM,IAAIG,OAAO,EAAEwC,QAAQ,EAAE;MAC5B,OAAOzG,QAAQ,CAAC,IAAI/B,OAAA,CAAAyI,uBAAuB,CAAC,4CAA4C,CAAC,CAAC;;IAG5F;IACA,IAAIvE,WAAW,EAAE;MACfpC,GAAG,CAACoE,YAAY,GAAGhC,WAAW;;IAGhC,IAAI,IAAAzD,QAAA,CAAAiI,SAAS,EAAC,IAAI,CAAC,IAAI,CAACb,cAAc,IAAIF,cAAc,IAAIA,cAAc,CAACgB,IAAI,KAAK,SAAS,EAAE;MAC7F7G,GAAG,GAAG;QACJ8G,MAAM,EAAE9G,GAAG;QACX+G,eAAe,EAAElB,cAAc,CAACmB,MAAM;OACvC;;IAGH,MAAMC,cAAc,GAAarF,MAAM,CAACsF,MAAM,CAC5C;MACEC,YAAY,EAAE,CAAC;MACfC,cAAc,EAAE,CAAC,CAAC;MAClBC,SAAS,EAAE,KAAK;MAChB;MACAC,WAAW,EAAEzB,cAAc,CAACyB,WAAW;KACxC,EACD1H,OAAO,CACR;IAED,MAAMsB,OAAO,GAAG6E,cAAc,GAC1B,IAAIxH,UAAA,CAAAgJ,YAAY,CAACxH,EAAE,CAACyH,EAAE,EAAExH,GAAG,EAAEiH,cAAc,CAAC,GAC5C,IAAI1I,UAAA,CAAAkJ,cAAc,CAAC1H,EAAE,CAACyH,EAAE,EAAExH,GAAG,EAAEiH,cAAc,CAAC;IAElD,IAAI;MACFS,KAAK,CAAC,IAAI,EAAExG,OAAO,EAAE+F,cAAc,EAAEhH,QAAQ,CAAC;KAC/C,CAAC,OAAO8D,GAAG,EAAE;MACZ9D,QAAQ,CAAC8D,GAAG,CAAC;;EAEjB;;AA5WA;AACgBvE,UAAA,CAAAmI,eAAe,GAAG1J,WAAA,CAAA0J,eAAe;AACjD;AACgBnI,UAAA,CAAAoI,iBAAiB,GAAG3J,WAAA,CAAA2J,iBAAiB;AACrD;AACgBpI,UAAA,CAAAqI,cAAc,GAAG5J,WAAA,CAAA4J,cAAc;AAC/C;AACgBrI,UAAA,CAAA6E,qBAAqB,GAAGpG,WAAA,CAAAoG,qBAAqB;AAC7D;AACgB7E,UAAA,CAAAkG,KAAK,GAAGzH,WAAA,CAAAyH,KAAK;AAC7B;AACgBlG,UAAA,CAAAsI,OAAO,GAAG7J,WAAA,CAAA6J,OAAO;AACjC;AACgBtI,UAAA,CAAA2F,MAAM,GAAGlH,WAAA,CAAAkH,MAAM;AAC/B;AACgB3F,UAAA,CAAA4F,QAAQ,GAAGnH,WAAA,CAAAmH,QAAQ;AApDxB2C,OAAA,CAAAvI,UAAA,GAAAA,UAAA;AAoZb;AACA,MAAawI,gBAAiB,SAAQxI,UAAU;EAI9CE,YAAYC,MAAc,EAAEC,OAA0B;IACpD,KAAK,CAACD,MAAM,EAAEC,OAAO,CAAC;IACtB,IAAI,CAACP,cAAc,CAAC,GAAGO,OAAO,CAACqI,aAAa;EAC9C;EAEA;EACS/H,OAAOA,CACdH,EAAoB,EACpBC,GAAa,EACbJ,OAAuB,EACvBK,QAAkB;IAElB,MAAMgI,aAAa,GAAG,IAAI,CAAC5I,cAAc,CAAC;IAC1C,IAAI,CAAC4I,aAAa,EAAE;MAClB,OAAOhI,QAAQ,CAAC,IAAI/B,OAAA,CAAAgK,2BAA2B,CAAC,2CAA2C,CAAC,CAAC;;IAG/F,MAAMC,iBAAiB,GAAG,IAAA9J,OAAA,CAAA+J,cAAc,EAAC,IAAI,CAAC;IAC9C,IAAID,iBAAiB,KAAK,CAAC,EAAE;MAC3B;MACA,OAAO,KAAK,CAACjI,OAAO,CAACH,EAAE,EAAEC,GAAG,EAAEJ,OAAO,EAAEK,QAAQ,CAAC;;IAGlD,IAAIkI,iBAAiB,GAAG,CAAC,EAAE;MACzBlI,QAAQ,CACN,IAAI/B,OAAA,CAAAyI,uBAAuB,CAAC,2DAA2D,CAAC,CACzF;MACD;;IAGF;IACA;IACA;IACA;IACA;IACA;IACA,MAAM0B,IAAI,GAA+BrI,GAAG,CAACsI,IAAI,IAAItI,GAAG,CAACuI,aAAa,GAAGvI,GAAG,CAACqI,IAAI,GAAG,IAAI;IACxF,MAAMG,SAAS,GAAiCxI,GAAG,CAACyI,aAAa,GAC7DzI,GAAG,CAAC0I,OAAO,CAACC,GAAG,CAAEC,KAAmC,IAAKA,KAAK,CAACC,GAAG,CAAC,GACnE,IAAI;IAERZ,aAAa,CAACa,OAAO,CAAC/I,EAAE,CAACgJ,QAAQ,EAAE,EAAE/I,GAAG,EAAEJ,OAAO,CAAC,CAACoJ,IAAI,CACrDC,SAAS,IAAG;MACV;MACA,IAAIZ,IAAI,IAAI,IAAI,KAAKrI,GAAG,CAACsI,IAAI,IAAItI,GAAG,CAACuI,aAAa,CAAC,EAAE;QACnDU,SAAS,CAACZ,IAAI,GAAGA,IAAI;;MAEvB,IAAIG,SAAS,IAAI,IAAI,IAAIxI,GAAG,CAACyI,aAAa,EAAE;QAC1C,KAAK,MAAM,CAACS,MAAM,EAAEN,KAAK,CAAC,IAAIJ,SAAS,CAAClF,OAAO,EAAE,EAAE;UACjD;UACA2F,SAAS,CAACP,OAAO,CAACQ,MAAM,CAAC,CAACL,GAAG,GAAGD,KAAK;;;MAIzC,KAAK,CAAC1I,OAAO,CAACH,EAAE,EAAEkJ,SAAS,EAAErJ,OAAO,EAAE,CAACmE,GAAG,EAAErC,QAAQ,KAAI;QACtD,IAAIqC,GAAG,IAAIrC,QAAQ,IAAI,IAAI,EAAE;UAC3BzB,QAAQ,CAAC8D,GAAG,EAAErC,QAAQ,CAAC;UACvB;;QAGFuG,aAAa,CAACkB,OAAO,CAACzH,QAAQ,EAAE9B,OAAO,CAAC,CAACoJ,IAAI,CAC3CI,GAAG,IAAInJ,QAAQ,CAAC4E,SAAS,EAAEuE,GAAG,CAAC,EAC/BrF,GAAG,IAAI9D,QAAQ,CAAC8D,GAAG,CAAC,CACrB;MACH,CAAC,CAAC;IACJ,CAAC,EACDA,GAAG,IAAG;MACJ,IAAIA,GAAG,EAAE;QACP9D,QAAQ,CAAC8D,GAAG,EAAE,IAAI,CAAC;;IAEvB,CAAC,CACF;EACH;;AA5EFgE,OAAA,CAAAC,gBAAA,GAAAA,gBAAA;AA+EA;AACA,SAAgBzB,iBAAiBA,CAAC8C,IAAgB;EAChD,MAAM5H,WAAW,GAAG4H,IAAI,CAAC5H,WAAW;EACpC,OAAOA,WAAW,CAAC6H,4BAA4B,IAAI,IAAI;AACzD;AAHAvB,OAAA,CAAAxB,iBAAA,GAAAA,iBAAA;AAKA,SAASP,aAAaA,CAACqD,IAAgB;EACrC,MAAM5H,WAAW,GAAG4H,IAAI,CAAC5H,WAAW;EACpC,IAAIA,WAAW,IAAI,IAAI,EAAE;IACvB,OAAO,KAAK;;EAGd,OAAO,IAAApD,OAAA,CAAA+J,cAAc,EAACiB,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC5H,WAAW,CAAC8H,sBAAsB;AACzE;AAEA,SAASlJ,gBAAgBA,CAACV,MAAc,EAAEC,OAA0B;EAClE,IAAIA,OAAO,CAAC4J,SAAS,EAAE;IACrB;IACA;IACA,OAAO5J,OAAO,CAAC6J,WAAW,CAACV,QAAQ,EAAE;;EAGvC,MAAM;IAAEW,aAAa;IAAEC;EAAU,CAAE,GAAGhK,MAAM;EAC5C,IAAI,OAAO+J,aAAa,KAAK,QAAQ,IAAI,OAAOC,UAAU,KAAK,QAAQ,EAAE;IACvE,OAAOtL,OAAA,CAAAuL,WAAW,CAACC,YAAY,CAACH,aAAa,EAAEC,UAAU,CAAC,CAACZ,QAAQ,EAAE;;EAGvE,OAAO,IAAA1K,OAAA,CAAAyL,MAAM,GAAE,CAACf,QAAQ,CAAC,KAAK,CAAC;AACjC;AAEA,SAASrB,KAAKA,CACZ2B,IAAgB,EAChBnJ,OAAiC,EACjCN,OAAuB,EACvBK,QAAkB;EAElBL,OAAO,GAAGA,OAAO,IAAI,EAAE;EACvB,MAAMoD,oBAAoB,GAAyB;IACjDQ,SAAS,EAAEtD,OAAO,CAACsD,SAAS;IAC5BG,EAAE,EAAE1D,QAAQ;IACZiE,OAAO,EAAEtE,OAAO,CAACsE,OAAO;IACxB6F,UAAU,EAAE,OAAOnK,OAAO,CAACmK,UAAU,KAAK,SAAS,GAAGnK,OAAO,CAACmK,UAAU,GAAG,KAAK;IAChFC,mBAAmB,EAAEpK,OAAO,CAACoK,mBAAmB;IAEhD;IACAC,WAAW,EAAE,OAAOrK,OAAO,CAACqK,WAAW,KAAK,SAAS,GAAGrK,OAAO,CAACqK,WAAW,GAAG,KAAK;IACnFC,YAAY,EAAE,OAAOtK,OAAO,CAACsK,YAAY,KAAK,SAAS,GAAGtK,OAAO,CAACsK,YAAY,GAAG,IAAI;IACrFC,aAAa,EAAE,OAAOvK,OAAO,CAACuK,aAAa,KAAK,SAAS,GAAGvK,OAAO,CAACuK,aAAa,GAAG,IAAI;IACxFC,cAAc,EAAE,OAAOxK,OAAO,CAACwK,cAAc,KAAK,SAAS,GAAGxK,OAAO,CAACwK,cAAc,GAAG,KAAK;IAC5FC,UAAU,EAAE,OAAOzK,OAAO,CAACyK,UAAU,KAAK,SAAS,GAAGzK,OAAO,CAACyK,UAAU,GAAG,KAAK;IAChFC,oBAAoB,EAClB,OAAO1K,OAAO,CAAC0K,oBAAoB,KAAK,SAAS,GAAG1K,OAAO,CAAC0K,oBAAoB,GAAG,IAAI;IACzFC,GAAG,EAAE,OAAO3K,OAAO,CAAC2K,GAAG,KAAK,SAAS,GAAG3K,OAAO,CAAC2K,GAAG,GAAG,KAAK;IAC3DC,OAAO,EAAE;GACV;EAED,IAAInB,IAAI,CAAClK,YAAY,CAAC,IAAIkK,IAAI,CAAClK,YAAY,CAAC,CAACsL,UAAU,EAAE;IACvDzH,oBAAoB,CAAC0H,gBAAgB,GAAGrB,IAAI,CAAClK,YAAY,CAAC,CAACsL,UAAU;IAErE,IAAIpB,IAAI,CAAClK,YAAY,CAAC,CAACwL,oBAAoB,EAAE;MAC3C3H,oBAAoB,CAAC2H,oBAAoB,GAAGtB,IAAI,CAAClK,YAAY,CAAC,CAACwL,oBAAoB;;;EAIvF,IAAI,OAAO/K,OAAO,CAACU,eAAe,KAAK,QAAQ,EAAE;IAC/C+I,IAAI,CAACzK,OAAO,CAAC,CAAC4D,UAAU,CAAC5C,OAAO,CAACU,eAAe,CAAC;GAClD,MAAM,IAAI+I,IAAI,CAAC/I,eAAe,KAAK,CAAC,EAAE;IACrC+I,IAAI,CAACzK,OAAO,CAAC,CAAC4D,UAAU,CAAC6G,IAAI,CAAC/I,eAAe,CAAC;;EAGhD;EACA,IAAI+I,IAAI,CAAC9I,eAAe,EAAE;IACxB8I,IAAI,CAACtG,IAAI,CAACvD,UAAU,CAACmI,eAAe,EAAE,IAAIrJ,2BAAA,CAAAsM,mBAAmB,CAACvB,IAAI,EAAEnJ,OAAO,CAAC,CAAC;IAE7E8C,oBAAoB,CAACwH,OAAO,GAAG,IAAAnM,OAAA,CAAAuC,GAAG,GAAE;IACpCoC,oBAAoB,CAACW,EAAE,GAAG,CAACI,GAAG,EAAE8G,KAAK,KAAI;MACvC;MACA;MACA;MACA,IAAI9G,GAAG,IAAI8G,KAAK,EAAErG,EAAE,KAAK,CAAC,EAAE;QAC1B6E,IAAI,CAACtG,IAAI,CACPvD,UAAU,CAACqI,cAAc,EACzB,IAAIvJ,2BAAA,CAAAwM,kBAAkB,CAACzB,IAAI,EAAEnJ,OAAO,EAAE6D,GAAG,EAAEf,oBAAoB,CAACwH,OAAO,CAAC,CACzE;OACF,MAAM;QACL,IAAIK,KAAK,KAAKA,KAAK,CAACrG,EAAE,KAAK,CAAC,IAAIqG,KAAK,CAACpG,IAAI,CAAC,EAAE;UAC3C4E,IAAI,CAACtG,IAAI,CACPvD,UAAU,CAACqI,cAAc,EACzB,IAAIvJ,2BAAA,CAAAwM,kBAAkB,CAACzB,IAAI,EAAEnJ,OAAO,EAAE2K,KAAK,EAAE7H,oBAAoB,CAACwH,OAAO,CAAC,CAC3E;SACF,MAAM;UACLnB,IAAI,CAACtG,IAAI,CACPvD,UAAU,CAACoI,iBAAiB,EAC5B,IAAItJ,2BAAA,CAAAyM,qBAAqB,CAAC1B,IAAI,EAAEnJ,OAAO,EAAE2K,KAAK,EAAE7H,oBAAoB,CAACwH,OAAO,CAAC,CAC9E;;;MAIL,IAAI,OAAOvK,QAAQ,KAAK,UAAU,EAAE;QAClC;QACA;QACA;QACA;QACAA,QAAQ,CAAC8D,GAAG,EAAEA,GAAG,YAAY7F,OAAA,CAAAqG,sBAAsB,GAAGM,SAAS,GAAGgG,KAAK,CAAC;;IAE5E,CAAC;;EAGH,IAAI,CAAC7H,oBAAoB,CAAC+G,UAAU,EAAE;IACpCV,IAAI,CAACvK,MAAM,CAAC,CAAC+E,GAAG,CAACb,oBAAoB,CAACQ,SAAS,EAAER,oBAAoB,CAAC;;EAGxE,IAAI;IACFqG,IAAI,CAACtK,cAAc,CAAC,CAACiM,YAAY,CAAC9K,OAAO,EAAE8C,oBAAoB,CAAC;GACjE,CAAC,OAAOiI,CAAC,EAAE;IACV,IAAI,CAACjI,oBAAoB,CAAC+G,UAAU,EAAE;MACpCV,IAAI,CAACvK,MAAM,CAAC,CAAC4E,MAAM,CAACV,oBAAoB,CAACQ,SAAS,CAAC;MACnDR,oBAAoB,CAACW,EAAE,CAACsH,CAAC,CAAC;MAC1B;;;EAIJ,IAAIjI,oBAAoB,CAAC+G,UAAU,EAAE;IACnC/G,oBAAoB,CAACW,EAAE,EAAE;;AAE7B;AAEA;AAEA;AACA,MAAauH,gBAAiB,SAAQ/M,aAAA,CAAAsB,iBAAmC;EAsDvEC,YAAYC,MAAc,EAAEC,OAA0B;IACpD,KAAK,EAAE;IAEP,IAAI,CAACC,YAAY,GAAG,IAAA7B,MAAA,CAAA8B,SAAS,EAC3B,CACEC,EAAoB,EACpBC,GAAa,EACbJ,OAAmC,EACnCK,QAAkB,KACf,IAAI,CAACC,OAAO,CAACH,EAAE,EAAEC,GAAG,EAAEJ,OAAO,EAAEK,QAAe,CAAC,CACrD;IAED,IAAI,CAACE,EAAE,GAAGP,OAAO,CAACO,EAAE;IACpB,IAAI,CAACC,OAAO,GAAGC,gBAAgB,CAACV,MAAM,EAAEC,OAAO,CAAC;IAChD,IAAI,CAACU,eAAe,GAAGV,OAAO,CAACU,eAAe,IAAI,CAAC;IACnD,IAAI,CAACC,eAAe,GAAGX,OAAO,CAACW,eAAe;IAC9C,IAAI,CAACC,SAAS,GAAGZ,OAAO,CAACY,SAAS;IAClC,IAAI,CAACC,MAAM,GAAG,KAAK;IACnB,IAAI,CAACrB,MAAM,CAAC,GAAG,IAAI;IACnB,IAAI,CAACF,YAAY,CAAC,GAAG,IAAI;IAEzB,IAAI,CAACC,YAAY,CAAC,GAAG,IAAIV,oBAAA,CAAAiC,iBAAiB,CAAC,IAAI,CAACN,OAAO,EAAER,OAAO,CAAC;IACjE,IAAI,CAACZ,WAAW,CAAC,GAAGY,OAAO,CAACe,UAAU;IACtC,IAAI,CAAC1B,YAAY,CAAC,GAAG,IAAAZ,OAAA,CAAAuC,GAAG,GAAE;IAE1B;IACA,IAAI,CAAC9B,MAAM,CAAC,GAAG,IAAI+B,GAAG,EAAE;IACxB,IAAI,CAAC9B,cAAc,CAAC,GAAG,IAAIP,gBAAA,CAAAsC,aAAa,CAAC;MACvC,GAAGlB,OAAO;MACVmB,kBAAkB,EAAE,IAAI,CAACC,KAAK,EAAED;KACjC,CAAC;IACF,IAAI,CAACoK,MAAM,GAAGxL,MAAM;IAEpB,IAAI,CAACL,iBAAiB,CAAC,GAAG,IAAI;IAE9B,IAAI,CAACP,cAAc,CAAC,CAACkC,EAAE,CAAC,SAAS,EAAEC,OAAO,IAAI,IAAI,CAACC,SAAS,CAACD,OAAO,CAAC,CAAC;IACtE,IAAI,CAACnC,cAAc,CAAC,CAACkC,EAAE,CAAC,OAAO,EAAEG,KAAK,IAAI,IAAI,CAACC,OAAO,CAACD,KAAK,CAAC,CAAC;IAC9D,IAAI,CAAC+J,MAAM,CAAClK,EAAE,CAAC,OAAO,EAAE,MAAM,IAAI,CAACK,OAAO,EAAE,CAAC;IAC7C,IAAI,CAAC6J,MAAM,CAAClK,EAAE,CAAC,SAAS,EAAE,MAAM,IAAI,CAACM,SAAS,EAAE,CAAC;IACjD,IAAI,CAAC4J,MAAM,CAAClK,EAAE,CAAC,OAAO,EAAE,MAAK;MAC3B;IAAA,CACD,CAAC;IAEF;IACA,IAAI,CAACkK,MAAM,CAAC3J,IAAI,CAAC,IAAI,CAACzC,cAAc,CAAC,CAAC;IACtC,IAAI,CAACA,cAAc,CAAC,CAACyC,IAAI,CAAC,IAAI,CAAC2J,MAAM,CAAC;EACxC;EAEA,IAAI1J,WAAWA,CAAA;IACb,OAAO,IAAI,CAACtC,YAAY,CAAC;EAC3B;EAEA,IAAI6B,KAAKA,CAAA;IACP,OAAO,IAAI,CAAC5B,MAAM,CAAC;EACrB;EAEA;EACA,IAAI4B,KAAKA,CAACU,QAAyB;IACjC,IAAI,CAACvC,YAAY,CAAC,CAACwC,eAAe,CAACD,QAAQ,CAAC;IAC5C,IAAI,CAACvC,YAAY,CAAC,GAAGyC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC1C,YAAY,CAAC,CAAC;IAEtD;IACA,IAAI,CAACC,MAAM,CAAC,GAAGsC,QAAQ;EACzB;EAEA;EACA,IAAII,sBAAsBA,CAACC,KAAc;IACvC,IAAI,CAAChD,cAAc,CAAC,CAAC+C,sBAAsB,GAAGC,KAAK;EACrD;EAEA,IAAID,sBAAsBA,CAAA;IACxB,OAAO,IAAI,CAAC/C,cAAc,CAAC,CAAC+C,sBAAsB;EACpD;EAEA,IAAIE,SAASA,CAAA;IACX,OAAO,IAAI,CAAChB,KAAK,EAAEgB,SAAS;EAC9B;EAEA,IAAIC,YAAYA,CAAA;IACd,OAAO,IAAI,CAACR,WAAW,CAACQ,YAAY;EACtC;EAEA,IAAItB,UAAUA,CAAA;IACZ,OAAO,IAAI,CAAC3B,WAAW,CAAC,IAAI,CAAC;EAC/B;EAEA,IAAI2B,UAAUA,CAACA,UAAkB;IAC/B,IAAI,CAAC3B,WAAW,CAAC,GAAG2B,UAAU;EAChC;EAEA,IAAIuB,QAAQA,CAAA;IACV,OAAO,IAAA7D,OAAA,CAAA8D,qBAAqB,EAAC,IAAI,CAAClD,YAAY,CAAC,CAAC;EAClD;EAEA,IAAImD,WAAWA,CAAA;IACb,OAAO,IAAI,CAAClD,YAAY,CAAC;EAC3B;EAEA,IAAIS,MAAMA,CAAA;IACR,OAAO,IAAI,CAACwL,MAAM;EACpB;EAEA,IAAI5E,iBAAiBA,CAAA;IACnB,OAAO,IAAI,CAAC9E,WAAW,CAAC6H,4BAA4B,IAAI,IAAI;EAC9D;EAEA,IAAItD,aAAaA,CAAA;IACf,OACE,IAAI,CAACvE,WAAW,IAAI,IAAI,IACxB,IAAApD,OAAA,CAAA+J,cAAc,EAAC,IAAyB,CAAC,IAAI,CAAC,IAC9C,CAAC,IAAI,CAAC3G,WAAW,CAAC8H,sBAAsB;EAE5C;EAEAlH,aAAaA,CAAA;IACX,IAAI,CAACpD,YAAY,CAAC,GAAG,IAAAZ,OAAA,CAAAuC,GAAG,GAAE;EAC5B;EAEAS,OAAOA,CAACD,KAAY;IAClB,IAAI,CAACkB,OAAO,CAAC,IAAI,EAAElB,KAAK,CAAC;EAC3B;EAEAE,OAAOA,CAAA;IACL,MAAMJ,OAAO,GAAG,cAAc,IAAI,CAACf,EAAE,OAAO,IAAI,CAACC,OAAO,SAAS;IACjE,IAAI,CAACkC,OAAO,CAAC,IAAI,EAAE,IAAIpE,OAAA,CAAAqE,iBAAiB,CAACrB,OAAO,CAAC,CAAC;EACpD;EAEAK,SAASA,CAAA;IACP,IAAI,CAACjC,iBAAiB,CAAC,GAAG,IAAAvB,QAAA,CAAAyE,UAAU,EAAC,MAAK;MACxC,MAAMtB,OAAO,GAAG,cAAc,IAAI,CAACf,EAAE,OAAO,IAAI,CAACC,OAAO,YAAY;MACpE,MAAMqC,eAAe,GAAG,IAAI,CAACzB,KAAK,IAAI,IAAI;MAC1C,IAAI,CAACsB,OAAO,CAAC,IAAI,EAAE,IAAIpE,OAAA,CAAAwE,wBAAwB,CAACxB,OAAO,EAAE;QAAEuB;MAAe,CAAE,CAAC,CAAC;IAChF,CAAC,EAAE,CAAC,CAAC,CAACE,KAAK,EAAE,CAAC,CAAC;EACjB;EAEAxB,SAASA,CAACD,OAAwC;IAChD,MAAM0B,gBAAgB,GAAG,IAAI,CAACtD,iBAAiB,CAAC;IAChD,IAAIsD,gBAAgB,IAAI,IAAI,EAAE;MAC5B,IAAA7E,QAAA,CAAA8E,YAAY,EAACD,gBAAgB,CAAC;MAC9B,IAAI,CAACtD,iBAAiB,CAAC,GAAG,IAAI;;IAGhC,MAAMgB,eAAe,GAAG,IAAI,CAAC6K,MAAM,CAACrI,OAAO,IAAI,CAAC;IAChD,IAAI,CAACqI,MAAM,CAAC3I,UAAU,CAAC,CAAC,CAAC;IAEzB;IACA,IAAI,CAACO,IAAI,CAAC,SAAS,EAAE7B,OAAO,CAAC;IAC7B,IAAI8B,oBAAoB,GAAG,IAAI,CAAClE,MAAM,CAAC,CAACmE,GAAG,CAAC/B,OAAO,CAACgC,UAAU,CAAC;IAE/D,IAAI,CAACF,oBAAoB,IAAI,IAAI,CAAClB,sBAAsB,EAAE;MACxD;MACA;MAEA;MACA,IAAI,IAAI,CAAChD,MAAM,CAAC,CAACqE,IAAI,GAAG,CAAC,EAAE;QACzB,IAAI,CAACb,OAAO,CAAC,IAAI,EAAE,IAAIpE,OAAA,CAAAkF,iBAAiB,CAAC7D,kBAAkB,CAAC,CAAC;OAC9D,MAAM;QACL;QACA,MAAM8D,KAAK,GAAG,IAAI,CAACvE,MAAM,CAAC,CAACwE,OAAO,EAAE,CAACC,IAAI,EAAE;QAC3C,IAAIF,KAAK,CAACtB,KAAK,IAAI,IAAI,EAAE;UACvB,MAAM,CAACyB,SAAS,EAAEC,QAAQ,CAAC,GAAmCJ,KAAK,CAACtB,KAAK;UACzE;UACAiB,oBAAoB,GAAGS,QAAQ;UAC/B;UACA,IAAI,CAAC3E,MAAM,CAAC,CAAC4E,MAAM,CAACF,SAAS,CAAC;;;;IAKpC,IAAI,CAACR,oBAAoB,EAAE;MACzB;;IAGF,MAAM/C,QAAQ,GAAG+C,oBAAoB,CAACW,EAAE;IAExC;IACA;IACA;IACA,IAAI,CAAC7E,MAAM,CAAC,CAAC4E,MAAM,CAACxC,OAAO,CAACgC,UAAU,CAAC;IACvC,IAAI,YAAY,IAAIhC,OAAO,IAAIA,OAAO,CAAC0C,UAAU,EAAE;MACjD;MACA;MACA;MACA;MACA,IAAI,CAAC9E,MAAM,CAAC,CAAC+E,GAAG,CAAC3C,OAAO,CAACsC,SAAS,EAAER,oBAAoB,CAAC;MACzD,IAAI,CAACmI,MAAM,CAAC3I,UAAU,CAAClC,eAAe,CAAC;;IAGzC,IAAI;MACF;MACAY,OAAO,CAAC4C,KAAK,CAACd,oBAAoB,CAAC;KACpC,CAAC,OAAOe,GAAG,EAAE;MACZ;MACA;MACA;MACA9D,QAAQ,CAAC8D,GAAG,CAAC;MACb;;IAGF,IAAI7C,OAAO,CAAC8C,SAAS,CAAC,CAAC,CAAC,EAAE;MACxB,MAAMC,QAAQ,GAAa/C,OAAO,CAAC8C,SAAS,CAAC,CAAC,CAAC;MAC/C,MAAME,OAAO,GAAGlB,oBAAoB,CAACkB,OAAO;MAC5C,IAAIA,OAAO,EAAE;QACX,IAAA9F,UAAA,CAAA+F,yBAAyB,EAACD,OAAO,EAAED,QAAQ,CAAC;;MAG9C,IAAIA,QAAQ,CAACG,YAAY,EAAE;QACzB,IAAI,CAAClF,YAAY,CAAC,GAAG+E,QAAQ,CAACG,YAAY;QAC1C,IAAI,CAACrB,IAAI,CAACvD,UAAU,CAAC6E,qBAAqB,EAAEJ,QAAQ,CAACG,YAAY,CAAC;;MAGpE,IAAIH,QAAQ,CAACK,iBAAiB,EAAE;QAC9BrE,QAAQ,CAAC,IAAI/B,OAAA,CAAAqG,sBAAsB,CAACN,QAAQ,CAACK,iBAAiB,EAAEL,QAAQ,CAAC,EAAEA,QAAQ,CAAC;QACpF;;MAGF,IAAIA,QAAQ,CAACO,EAAE,KAAK,CAAC,IAAIP,QAAQ,CAACQ,IAAI,IAAIR,QAAQ,CAACS,MAAM,IAAIT,QAAQ,CAACU,IAAI,EAAE;QAC1E1E,QAAQ,CAAC,IAAI/B,OAAA,CAAA0G,gBAAgB,CAACX,QAAQ,CAAC,CAAC;QACxC;;;IAIJhE,QAAQ,CAAC4E,SAAS,EAAE3D,OAAO,CAAC8C,SAAS,CAAC,CAAC,CAAC,CAAC;EAC3C;EAEAc,OAAOA,CAAClF,OAAuB,EAAEK,QAAmB;IAClD,IAAI,IAAI,CAACQ,MAAM,EAAE;MACfsE,OAAO,CAACC,QAAQ,CAAC,MAAM/E,QAAQ,GAAE,CAAE,CAAC;MACpC;;IAEF,IAAI,OAAOA,QAAQ,KAAK,UAAU,EAAE;MAClC,IAAI,CAACgF,IAAI,CAAC,OAAO,EAAE,MAAMF,OAAO,CAACC,QAAQ,CAAC,MAAM/E,QAAQ,EAAE,CAAC,CAAC;;IAG9D;IACA;IACA;IACA,IAAI,CAACiF,kBAAkB,CAAC1F,UAAU,CAAC2F,MAAM,CAAC;IAC1C,IAAI,CAACD,kBAAkB,CAAC1F,UAAU,CAAC4F,QAAQ,CAAC;IAC5C,MAAMlE,OAAO,GAAG,cAAc,IAAI,CAACf,EAAE,OAAO,IAAI,CAACC,OAAO,SAAS;IACjE,IAAI,CAACkC,OAAO,CAAC1C,OAAO,CAACyF,KAAK,EAAE,IAAInH,OAAA,CAAAqE,iBAAiB,CAACrB,OAAO,CAAC,CAAC;EAC7D;EAEA;;;;;;;;EAQQoB,OAAOA,CAAC+C,KAAc,EAAEjE,KAAa;IAC3C,IAAI,IAAI,CAACX,MAAM,EAAE;MACf;;IAGF,IAAI,CAACA,MAAM,GAAG,IAAI;IAElB,MAAM6E,eAAe,GAAGA,CAAA,KAAK;MAC3B,KAAK,MAAMC,EAAE,IAAI,IAAI,CAACzG,MAAM,CAAC,CAAC0G,MAAM,EAAE,EAAE;QACtCD,EAAE,CAAC5B,EAAE,CAACvC,KAAK,CAAC;;MAGd,IAAI,CAACtC,MAAM,CAAC,CAAC2G,KAAK,EAAE;MAEpB,IAAI,CAAC1C,IAAI,CAACvD,UAAU,CAACkG,KAAK,CAAC;IAC7B,CAAC;IAED,IAAI,CAACyF,MAAM,CAACjG,kBAAkB,EAAE;IAChC,IAAI,CAACnG,cAAc,CAAC,CAACmG,kBAAkB,EAAE;IAEzC,IAAI,CAACnG,cAAc,CAAC,CAAC+F,OAAO,EAAE;IAE9B,IAAIO,KAAK,EAAE;MACT,IAAI,CAAC8F,MAAM,CAACrG,OAAO,EAAE;MACrBQ,eAAe,EAAE;MACjB;;IAGF,IAAI,CAAC,IAAI,CAAC6F,MAAM,CAACxF,aAAa,EAAE;MAC9B,IAAI,CAACwF,MAAM,CAACvF,GAAG,CAAC,MAAK;QACnB,IAAI,CAACuF,MAAM,CAACrG,OAAO,EAAE;QACrBQ,eAAe,EAAE;MACnB,CAAC,CAAC;KACH,MAAM;MACLA,eAAe,EAAE;;EAErB;EAEApF,OAAOA,CACLH,EAAoB,EACpBG,OAAiB,EACjBN,OAAmC,EACnCK,QAAkB;IAElB,IAAID,GAAG,GAAG;MAAE,GAAGE;IAAO,CAAE;IAExB,MAAM2F,cAAc,GAAG,IAAAlH,QAAA,CAAAmH,iBAAiB,EAAClG,OAAO,CAAC;IACjD,MAAMsE,OAAO,GAAGtE,OAAO,EAAEsE,OAAO;IAEhC,IAAI9B,WAAW,GAAG,IAAI,CAACA,WAAW;IAElC,IAAI,IAAI,CAAC5B,SAAS,EAAE;MAClB,MAAM;QAAEyF,OAAO;QAAEC,MAAM;QAAEC;MAAiB,CAAE,GAAG,IAAI,CAAC3F,SAAS;MAC7DR,GAAG,CAACoG,UAAU,GAAGH,OAAO;MACxB,IAAIC,MAAM,IAAI,IAAI,EAAElG,GAAG,CAACqG,SAAS,GAAGH,MAAM;MAC1C,IAAIC,iBAAiB,IAAI,IAAI,EAAEnG,GAAG,CAACsG,oBAAoB,GAAGH,iBAAiB;;IAG7E,IAAI,IAAI,CAACI,iBAAiB,IAAIrC,OAAO,EAAE;MACrC,IACEA,OAAO,CAAC9B,WAAW,IACnBA,WAAW,IACX8B,OAAO,CAAC9B,WAAW,CAACA,WAAW,CAACoE,WAAW,CAACpE,WAAW,CAACA,WAAW,CAAC,EACpE;QACAA,WAAW,GAAG8B,OAAO,CAAC9B,WAAW;;MAGnC,MAAM2B,GAAG,GAAG,IAAA3F,UAAA,CAAAqI,YAAY,EAACvC,OAAO,EAAElE,GAAG,EAAEJ,OAAO,CAAC;MAC/C,IAAImE,GAAG,EAAE;QACP,OAAO9D,QAAQ,CAAC8D,GAAG,CAAC;;KAEvB,MAAM,IAAIG,OAAO,EAAEwC,QAAQ,EAAE;MAC5B,OAAOzG,QAAQ,CAAC,IAAI/B,OAAA,CAAAyI,uBAAuB,CAAC,4CAA4C,CAAC,CAAC;;IAG5F;IACA,IAAIvE,WAAW,EAAE;MACfpC,GAAG,CAACoE,YAAY,GAAGhC,WAAW;;IAGhC;IACE;IACA,IAAAzD,QAAA,CAAAiI,SAAS,EAAC,IAAI,CAAC,IACf,CAAC,IAAI,CAACZ,aAAa,IACnBH,cAAc,IACdA,cAAc,CAACgB,IAAI,KAAK,SAAS,EACjC;MACA7G,GAAG,GAAG;QACJ8G,MAAM,EAAE9G,GAAG;QACX+G,eAAe,EAAElB,cAAc,CAACmB,MAAM;OACvC;;IAGH,MAAMC,cAAc,GAAarF,MAAM,CAACsF,MAAM,CAC5C;MACEC,YAAY,EAAE,CAAC;MACfC,cAAc,EAAE,CAAC,CAAC;MAClBC,SAAS,EAAE,KAAK;MAChB;MACAC,WAAW,EAAEzB,cAAc,CAACyB,WAAW;KACxC,EACD1H,OAAO,CACR;IAED,MAAMsB,OAAO,GAAG,IAAI,CAAC8E,aAAa,GAC9B,IAAIzH,UAAA,CAAAgJ,YAAY,CAACxH,EAAE,CAACyH,EAAE,EAAExH,GAAG,EAAEiH,cAAc,CAAC,GAC5C,IAAI1I,UAAA,CAAAkJ,cAAc,CAAC1H,EAAE,CAACyH,EAAE,EAAExH,GAAG,EAAEiH,cAAc,CAAC;IAElD,IAAI;MACFS,KAAK,CAAC,IAAyB,EAAExG,OAAO,EAAE+F,cAAc,EAAEhH,QAAQ,CAAC;KACpE,CAAC,OAAO8D,GAAG,EAAE;MACZ9D,QAAQ,CAAC8D,GAAG,CAAC;;EAEjB;;AA7XA;AACgBmH,gBAAA,CAAAvD,eAAe,GAAG1J,WAAA,CAAA0J,eAAe;AACjD;AACgBuD,gBAAA,CAAAtD,iBAAiB,GAAG3J,WAAA,CAAA2J,iBAAiB;AACrD;AACgBsD,gBAAA,CAAArD,cAAc,GAAG5J,WAAA,CAAA4J,cAAc;AAC/C;AACgBqD,gBAAA,CAAA7G,qBAAqB,GAAGpG,WAAA,CAAAoG,qBAAqB;AAC7D;AACgB6G,gBAAA,CAAAxF,KAAK,GAAGzH,WAAA,CAAAyH,KAAK;AAC7B;AACgBwF,gBAAA,CAAApD,OAAO,GAAG7J,WAAA,CAAA6J,OAAO;AACjC;AACgBoD,gBAAA,CAAA/F,MAAM,GAAGlH,WAAA,CAAAkH,MAAM;AAC/B;AACgB+F,gBAAA,CAAA9F,QAAQ,GAAGnH,WAAA,CAAAmH,QAAQ;AApDxB2C,OAAA,CAAAmD,gBAAA,GAAAA,gBAAA;AAqab,MAAME,0BAA0B,GAAG,IAAI,GAAG,IAAI,GAAG,EAAE,GAAG,CAAC;AAEvD;;;;;;;;;;;AAWO,gBAAgBC,wBAAwBA,CAC7CC,UAA4B;EAE5B,MAAMC,UAAU,GAAG,IAAIlN,OAAA,CAAAmN,UAAU,EAAE;EACnC,MAAMzK,kBAAkB,GAAGuK,UAAU,CAACtK,KAAK,EAAED,kBAAkB,IAAIqK,0BAA0B;EAC7F,WAAW,MAAM,CAACK,KAAK,CAAC,IAAI,IAAA3N,QAAA,CAAAmD,EAAE,EAACqK,UAAU,CAACH,MAAM,EAAE,MAAM,CAAC,EAAE;IACzDI,UAAU,CAACG,MAAM,CAACD,KAAK,CAAC;IACxB,MAAME,aAAa,GAAGJ,UAAU,CAACK,QAAQ,EAAE;IAE3C,IAAID,aAAa,IAAI,IAAI,EAAE;MACzB;;IAGF,IAAIA,aAAa,GAAG,CAAC,EAAE;MACrB,MAAM,IAAIzN,OAAA,CAAA2N,eAAe,CAAC,yBAAyBF,aAAa,EAAE,CAAC;;IAGrE,IAAIA,aAAa,GAAG5K,kBAAkB,EAAE;MACtC,MAAM,IAAI7C,OAAA,CAAA2N,eAAe,CACvB,yBAAyBF,aAAa,kBAAkB5K,kBAAkB,EAAE,CAC7E;;IAGH,IAAI4K,aAAa,GAAGJ,UAAU,CAACO,MAAM,EAAE;MACrC;;IAGF,MAAMP,UAAU,CAACQ,IAAI,CAACJ,aAAa,CAAC;;AAExC;AA7BA5D,OAAA,CAAAsD,wBAAA,GAAAA,wBAAA;AA+BA;;;;;;AAMO,eAAeL,YAAYA,CAChCM,UAA4B,EAC5BpL,OAAiC,EACjCN,OAAyF;EAEzF,MAAMoM,OAAO,GAAG,IAAApO,QAAA,CAAAqH,IAAI,EAACqG,UAAU,CAACH,MAAM,EAAE,OAAO,CAAC;EAChD,MAAMc,YAAY,GAChBrM,OAAO,CAAC8K,gBAAgB,KAAK,MAAM,IAAI,CAACnM,UAAA,CAAA2N,mBAAmB,CAACC,WAAW,CAACjM,OAAO,CAAC,GAC5EA,OAAO,GACP,IAAI3B,UAAA,CAAA2N,mBAAmB,CAAChM,OAAO,EAAE;IAC/BwK,gBAAgB,EAAE9K,OAAO,CAAC8K,gBAAgB,IAAI,MAAM;IACpDC,oBAAoB,EAAE/K,OAAO,CAAC+K,oBAAoB,IAAI;GACvD,CAAC;EACR,MAAMyB,MAAM,GAAGC,MAAM,CAACC,MAAM,CAAC,MAAML,YAAY,CAACM,KAAK,EAAE,CAAC;EACxDjB,UAAU,CAACH,MAAM,CAACqB,IAAI,CAACJ,MAAM,CAAC;EAC9B,MAAMJ,OAAO;AACf;AAhBAjE,OAAA,CAAAiD,YAAA,GAAAA,YAAA;AAkBA;;;;;;;;;AASO,gBAAgByB,QAAQA,CAC7BnB,UAA4B;EAE5B,WAAW,MAAMpK,OAAO,IAAImK,wBAAwB,CAACC,UAAU,CAAC,EAAE;IAChE,MAAM5J,QAAQ,GAAG,MAAM,IAAAhD,aAAA,CAAAgO,kBAAkB,EAACxL,OAAO,CAAC;IAClD,MAAMQ,QAAQ;IAEd,IAAI,EAAE,YAAY,IAAIA,QAAQ,CAAC,IAAI,CAACA,QAAQ,CAACkC,UAAU,EAAE;MACvD;;;AAGN;AAXAmE,OAAA,CAAA0E,QAAA,GAAAA,QAAA;AAaA;;;;;AAKO,eAAeV,IAAIA,CAACT,UAA4B;EACrD,WAAW,MAAMvJ,KAAK,IAAI0K,QAAQ,CAACnB,UAAU,CAAC,EAAE;IAC9C,OAAOvJ,KAAK;;EAGd,MAAM,IAAI7D,OAAA,CAAAkF,iBAAiB,CAAC,0CAA0C,CAAC;AACzE;AANA2E,OAAA,CAAAgE,IAAA,GAAAA,IAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}